---
phase: 14-argument-parsing-and-dual-mode-pattern
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/args.sh
  - scripts/lib/output.sh
  - scripts/common.sh
  - scripts/nmap/examples.sh
autonomous: true

must_haves:
  truths:
    - "parse_common_args extracts -h, -v, -q, -x flags and passes everything else to REMAINING_ARGS"
    - "run_or_show prints info+indented command+blank line in show mode (byte-identical to current pattern)"
    - "run_or_show executes the command in execute mode"
    - "confirm_execute prompts for confirmation in execute mode, no-ops in show mode"
    - "nmap/examples.sh backward compatible: same output without -x flag"
    - "nmap/examples.sh accepts -h, -v, -q, -x flags through parse_common_args"
  artifacts:
    - path: "scripts/lib/args.sh"
      provides: "parse_common_args function with source guard"
      contains: "parse_common_args"
    - path: "scripts/lib/output.sh"
      provides: "run_or_show and confirm_execute functions"
      contains: "run_or_show"
    - path: "scripts/common.sh"
      provides: "args.sh sourced in module load chain"
      contains: "args.sh"
    - path: "scripts/nmap/examples.sh"
      provides: "Pilot migration using parse_common_args and run_or_show"
      contains: "parse_common_args"
  key_links:
    - from: "scripts/lib/args.sh"
      to: "scripts/lib/logging.sh"
      via: "references VERBOSE and LOG_LEVEL globals"
      pattern: "VERBOSE|LOG_LEVEL"
    - from: "scripts/lib/output.sh"
      to: "scripts/lib/args.sh"
      via: "run_or_show reads EXECUTE_MODE global set by parse_common_args"
      pattern: "EXECUTE_MODE"
    - from: "scripts/common.sh"
      to: "scripts/lib/args.sh"
      via: "source in module load chain after output.sh"
      pattern: "source.*args.sh"
    - from: "scripts/nmap/examples.sh"
      to: "scripts/lib/args.sh"
      via: "calls parse_common_args and uses REMAINING_ARGS"
      pattern: "parse_common_args"
---

<objective>
Create the argument parsing library module (args.sh), add dual-mode functions (run_or_show, confirm_execute) to output.sh, wire into common.sh, and pilot-migrate nmap/examples.sh.

Purpose: Establish the shared arg parser and dual-mode execution pattern that all 66 scripts will adopt in Phases 15-16. Prove it works on one real script before mass migration.
Output: New args.sh module, enhanced output.sh, updated common.sh load chain, migrated nmap/examples.sh.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/14-argument-parsing-and-dual-mode-pattern/14-RESEARCH.md
@.planning/phases/13-library-infrastructure/13-01-SUMMARY.md

@scripts/common.sh
@scripts/lib/output.sh
@scripts/lib/logging.sh
@scripts/nmap/examples.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create args.sh module and add run_or_show/confirm_execute to output.sh</name>
  <files>scripts/lib/args.sh, scripts/lib/output.sh, scripts/common.sh</files>
  <action>
**Create `scripts/lib/args.sh`** with:
- Source guard pattern: `[[ -n "${_ARGS_LOADED:-}" ]] && return 0` + `_ARGS_LOADED=1`
- Global `EXECUTE_MODE="${EXECUTE_MODE:-show}"` (default: show)
- Global `REMAINING_ARGS=()` (empty array)
- `parse_common_args()` function using manual while/case/shift loop (NOT getopts -- ARGS-02):
  - `-h|--help` -> calls `show_help` (must be defined by caller) then `exit 0`
  - `-v|--verbose` -> increments `VERBOSE=$((VERBOSE + 1))` AND sets `LOG_LEVEL="debug"` (both, per pitfall 8)
  - `-q|--quiet` -> sets `LOG_LEVEL="warn"` (NOT "error" -- preserves safety warnings)
  - `-x|--execute` -> sets `EXECUTE_MODE="execute"`
  - `--` -> `shift` then `REMAINING_ARGS+=("$@")` then `break`
  - `*` -> `REMAINING_ARGS+=("$1")` (catch-all: positional args AND unknown flags pass through -- ARGS-03/ARGS-04)
  - `shift` at end of loop body
- Use exact code from research "Complete args.sh Module" section

**Add to `scripts/lib/output.sh`** (append after existing functions, before the closing comment):
- `run_or_show()` function:
  - Takes `description` as `$1`, remaining args are the command
  - Show mode (`EXECUTE_MODE != "execute"`): prints `info "$description"` then `echo "   $*"` then `echo ""` -- byte-identical to current 3-line pattern
  - Execute mode: prints `info "$description"` then `debug "Executing: $*"` then runs `"$@"` (preserving argument quoting) then `echo ""`
- `confirm_execute()` function:
  - Takes optional `target` as `$1`
  - Returns immediately (return 0) if `EXECUTE_MODE != "execute"` -- zero impact on show mode
  - In execute mode: checks `[[ ! -t 0 ]]` and exits 1 with warning if non-interactive
  - Prints warning about execute mode, prompts `Continue? [y/N]`, exits 0 if not confirmed
- Use exact code from research "Complete run_or_show and confirm_execute" section

**Modify `scripts/common.sh`** to source args.sh:
- Add `source "${_LIB_DIR}/args.sh"` AFTER the `output.sh` line and BEFORE the `diagnostic.sh` line
- This is the only change to common.sh -- one new line

CRITICAL: The `echo "   $*"` in run_or_show show mode must produce output identical to the current `echo "   nmap -sn ${TARGET}"` pattern. Since `$*` expands to space-separated args with variables already expanded, this is correct. Verify mentally: `run_or_show "desc" nmap -sn "$TARGET"` -> `$*` is `nmap -sn scanme.nmap.org` -> `echo "   nmap -sn scanme.nmap.org"` which matches.

CRITICAL: Use `${REMAINING_ARGS[@]+${REMAINING_ARGS[@]}}` expansion pattern in any place that expands the array (for Bash 4.0-4.3 empty array safety under set -u). The args.sh module itself initializes `REMAINING_ARGS=()` which is safe; the expansion pattern is needed by consumer scripts in their `set --` line.
  </action>
  <verify>
Verify source chain works:
```bash
bash -c 'source scripts/common.sh && declare -F parse_common_args && declare -F run_or_show && declare -F confirm_execute && echo "All 3 functions loaded"'
```
Expected: prints function declarations and "All 3 functions loaded".

Verify source guard:
```bash
bash -c 'source scripts/common.sh && echo "_ARGS_LOADED=${_ARGS_LOADED}"'
```
Expected: `_ARGS_LOADED=1`

Verify EXECUTE_MODE default:
```bash
bash -c 'source scripts/common.sh && echo "EXECUTE_MODE=${EXECUTE_MODE}"'
```
Expected: `EXECUTE_MODE=show`
  </verify>
  <done>
- scripts/lib/args.sh exists with source guard, EXECUTE_MODE, REMAINING_ARGS, and parse_common_args()
- scripts/lib/output.sh has run_or_show() and confirm_execute() appended
- scripts/common.sh sources args.sh between output.sh and diagnostic.sh
- All 3 new functions load successfully via `source common.sh`
- EXECUTE_MODE defaults to "show"
  </done>
</task>

<task type="auto">
  <name>Task 2: Pilot-migrate nmap/examples.sh to use parse_common_args and run_or_show</name>
  <files>scripts/nmap/examples.sh</files>
  <action>
**Before modifying**, capture baseline output for backward-compatibility diff:
```bash
bash scripts/nmap/examples.sh scanme.nmap.org 2>/dev/null > /tmp/nmap-before.txt
```

**Modify `scripts/nmap/examples.sh`**:

1. **Remove** the inline help check line:
   ```
   [[ "${1:-}" =~ ^(-h|--help)$ ]] && show_help && exit 0
   ```

2. **Add** after `show_help()` and before `require_cmd`:
   ```bash
   parse_common_args "$@"
   set -- "${REMAINING_ARGS[@]+${REMAINING_ARGS[@]}}"
   ```

3. **Add** `confirm_execute "${1:-}"` AFTER `require_target "${1:-}"` and BEFORE `safety_banner`:
   ```bash
   require_cmd nmap "brew install nmap"
   require_target "${1:-}"
   confirm_execute "${1:-}"
   safety_banner
   ```

4. **Replace** each `info + echo + echo` triple with `run_or_show`:
   - Example 1: `run_or_show "1) Ping scan -- is the host up?" nmap -sn "$TARGET"`
   - Example 2: `run_or_show "2) Quick scan -- top 100 ports" nmap -F "$TARGET"`
   - Example 3: `run_or_show "3) Service/version detection" nmap -sV "$TARGET"`
   - Example 4: `run_or_show "4) OS detection (requires sudo)" sudo nmap -O "$TARGET"`
   - Example 5: `run_or_show "5) Aggressive scan (combines -O -sV -sC --traceroute)" sudo nmap -A "$TARGET"`
   - Example 6: `run_or_show "6) Full port scan (slow but thorough)" nmap -p- "$TARGET"`
   - Example 7: `run_or_show "7) UDP scan on common ports (requires sudo)" sudo nmap -sU --top-ports 20 "$TARGET"`
   - Example 8: `run_or_show "8) Run vulnerability detection scripts" nmap --script vuln "$TARGET"`
   - Example 9: Keep as static `info + echo + echo` (hardcoded subnet, not $TARGET -- cannot use run_or_show)
   - Example 10: Note the current indentation uses 4 spaces (`echo "    nmap ..."`), not 3. Check the original file carefully. If example 10 has 4-space indent, use `run_or_show` which produces 3-space indent. Actually, to maintain byte-identical output, look at the ACTUAL indent in the file. If example 10 uses 4 spaces while others use 3, keep example 10 as static `info + echo + echo` to preserve exact output, OR adjust run_or_show indent. READ THE FILE CAREFULLY for exact whitespace.

   Actually, re-reading the nmap/examples.sh: examples 1-9 use `echo "   ..."` (3 spaces) but example 10 uses `echo "    nmap ..."` (4 spaces). This is a minor inconsistency in the original. For the pilot, convert examples 1-8 to run_or_show (which uses 3-space indent). Keep example 9 as static (hardcoded subnet). For example 10, convert to run_or_show (normalizing to 3-space indent) since this is a cleanup improvement, not a behavioral change.

5. **Guard the interactive demo** with execute mode check:
   ```bash
   # Interactive demo (skip if non-interactive)
   if [[ "${EXECUTE_MODE:-show}" == "show" ]]; then
       [[ ! -t 0 ]] && exit 0
       read -rp "Run a quick ping scan on ${TARGET} now? [y/N] " answer
       if [[ "$answer" =~ ^[Yy]$ ]]; then
           info "Running: nmap -sn ${TARGET}"
           nmap -sn "$TARGET"
       fi
   fi
   ```

6. **Keep** the `show_help()` function UNCHANGED -- parse_common_args calls it when -h is passed. Keep the `info "=== Nmap Examples ==="` and `info "Target: ${TARGET}"` header lines as-is.

7. **Keep** all comment lines (# 1. Quick host discovery, etc.) for readability.

**After modifying**, verify backward compatibility:
```bash
bash scripts/nmap/examples.sh scanme.nmap.org 2>/dev/null > /tmp/nmap-after.txt
diff /tmp/nmap-before.txt /tmp/nmap-after.txt
```
The diff should show zero differences (or only the example 10 indent normalization from 4->3 spaces, which is acceptable).
  </action>
  <verify>
Backward compatibility -- show mode output unchanged:
```bash
bash scripts/nmap/examples.sh scanme.nmap.org 2>/dev/null > /tmp/nmap-after.txt
diff /tmp/nmap-before.txt /tmp/nmap-after.txt
```
Expected: no differences (or only minor whitespace normalization on example 10).

Help flag works:
```bash
bash scripts/nmap/examples.sh --help 2>&1 | head -1
bash scripts/nmap/examples.sh -h 2>&1 | head -1
```
Expected: both print "Usage: examples.sh <target>"

Unknown flags pass through:
```bash
bash scripts/nmap/examples.sh --custom-thing scanme.nmap.org 2>/dev/null | head -3
```
Expected: produces output (no error about unknown flag).

Execute mode check (non-interactive should fail):
```bash
echo "" | bash scripts/nmap/examples.sh -x scanme.nmap.org 2>&1 | grep -i "interactive"
```
Expected: warning about requiring interactive terminal.
  </verify>
  <done>
- nmap/examples.sh uses parse_common_args instead of inline help check
- 8 examples converted to run_or_show, 1 kept as static (example 9, hardcoded subnet), 1 converted with normalized indent (example 10)
- Interactive demo guarded by EXECUTE_MODE check
- Show-mode output is backward compatible (diff confirms)
- -h/--help prints usage, -x mode requires interactive terminal confirmation
- Unknown flags pass through without error
  </done>
</task>

</tasks>

<verification>
All verification runs against scripts/nmap/examples.sh as the pilot:
1. `bash scripts/nmap/examples.sh --help` and `-h` both print usage
2. `bash scripts/nmap/examples.sh scanme.nmap.org` output matches pre-migration (diff)
3. Execute mode requires interactive terminal (piped input rejected)
4. Unknown flags pass through to REMAINING_ARGS without error
5. All 3 new functions (parse_common_args, run_or_show, confirm_execute) load via common.sh
</verification>

<success_criteria>
- args.sh module created with parse_common_args handling -h/-v/-q/-x and passthrough
- output.sh enhanced with run_or_show and confirm_execute
- common.sh sources args.sh in correct position
- nmap/examples.sh migrated and backward-compatible in show mode
- All new functions accessible by any script that sources common.sh
</success_criteria>

<output>
After completion, create `.planning/phases/14-argument-parsing-and-dual-mode-pattern/14-01-SUMMARY.md`
</output>
