---
phase: 28-safety-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .claude/hooks/netsec-pretool.sh
  - .claude/hooks/netsec-posttool.sh
  - .claude/settings.json
  - .gitignore
autonomous: true
requirements:
  - SAFE-01
  - SAFE-02
  - SAFE-03
  - SAFE-04

must_haves:
  truths:
    - "A Bash command targeting an IP not in scope.json is blocked before execution with an actionable deny message"
    - "A raw tool command (e.g., nmap 10.0.0.1) is blocked with a redirect to the correct wrapper script"
    - "A wrapper script invocation with -j that produces a JSON envelope injects a one-line summary into additionalContext"
    - "Both blocked and executed commands produce timestamped JSONL entries in .pentest/audit-YYYY-MM-DD.jsonl"
    - "Non-security commands (git, ls, npm) pass through with zero processing"
  artifacts:
    - path: ".claude/hooks/netsec-pretool.sh"
      provides: "PreToolUse target validation and raw tool interception"
      min_lines: 80
    - path: ".claude/hooks/netsec-posttool.sh"
      provides: "PostToolUse JSON bridge and audit logging"
      min_lines: 50
    - path: ".claude/settings.json"
      provides: "Hook registrations for PreToolUse and PostToolUse"
      contains: "PreToolUse"
    - path: ".gitignore"
      provides: "Excludes .pentest/ from version control"
      contains: ".pentest/"
  key_links:
    - from: ".claude/settings.json"
      to: ".claude/hooks/netsec-pretool.sh"
      via: "PreToolUse hook registration with Bash matcher"
      pattern: "netsec-pretool"
    - from: ".claude/settings.json"
      to: ".claude/hooks/netsec-posttool.sh"
      via: "PostToolUse hook registration with Bash matcher"
      pattern: "netsec-posttool"
    - from: ".claude/hooks/netsec-pretool.sh"
      to: ".pentest/scope.json"
      via: "Reads scope file for target allowlist validation"
      pattern: "scope\\.json"
    - from: ".claude/hooks/netsec-posttool.sh"
      to: ".pentest/audit-"
      via: "Appends JSONL entries to date-stamped audit file"
      pattern: "audit-.*\\.jsonl"
---

<objective>
Implement PreToolUse and PostToolUse safety hooks that validate pentesting commands before execution, parse JSON output afterward, and log all activity to an audit trail.

Purpose: This is the safety foundation for the entire v1.5 Claude Skill Pack. Every subsequent phase depends on these hooks to enforce target scope, intercept raw tool usage, bridge JSON output to Claude, and maintain an audit trail.

Output: Two executable hook scripts registered in settings.json, with .pentest/ gitignored for audit logs and scope data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-safety-architecture/28-RESEARCH.md
@.claude/settings.json
@scripts/lib/json.sh
@scripts/check-tools.sh
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PreToolUse hook for target validation and raw tool interception</name>
  <files>.claude/hooks/netsec-pretool.sh</files>
  <action>
Create `.claude/hooks/netsec-pretool.sh` (executable) implementing the PreToolUse safety hook.

**Input handling:**
- Read full JSON from stdin into a variable: `INPUT=$(cat)`
- Extract `tool_name` and `tool_input.command` using jq
- Fast exit: if `tool_name` is not "Bash", exit 0 immediately (no output)

**Fast exit for non-security commands (critical for performance):**
- Define the security tools regex: `nmap|tshark|nikto|sqlmap|msfconsole|msfvenom|msfdb|hashcat|john|hping3|skipfish|aircrack-ng|airodump-ng|aireplay-ng|airmon-ng|gobuster|ffuf|foremost|dig|curl|nc|netcat|ncat|traceroute|mtr`
- If the command does NOT contain `scripts/` AND does NOT match any security tool name, exit 0 immediately
- This ensures git, ls, npm, node, python, etc. add zero latency

**SAFE-02: Raw tool interception (check BEFORE target validation):**
- Detect if the command starts with an optional `sudo ` followed by a raw tool name (not preceded by `bash scripts/` or containing `scripts/`)
- Be careful about false positives: `grep nmap README.md` should NOT trigger (the tool name must be the main command, not an argument to another command)
- Use pattern: command starts with `^(sudo\s+)?TOOL_NAME\b` where TOOL_NAME is one of the security tools
- BUT exclude commands where the tool name appears as an argument to another command (e.g., `grep nmap`, `which nmap`, `command -v nmap`, `type nmap`, `cat scripts/nmap/...`, `ls scripts/nmap/`)
- Build a tool-to-script-directory mapping using an associative array:
  ```
  nmap -> scripts/nmap/
  tshark -> scripts/tshark/
  msfconsole -> scripts/metasploit/
  msfvenom -> scripts/metasploit/
  msfdb -> scripts/metasploit/
  sqlmap -> scripts/sqlmap/
  nikto -> scripts/nikto/
  hashcat -> scripts/hashcat/
  john -> scripts/john/
  hping3 -> scripts/hping3/
  skipfish -> scripts/skipfish/
  aircrack-ng -> scripts/aircrack-ng/
  airodump-ng -> scripts/aircrack-ng/
  aireplay-ng -> scripts/aircrack-ng/
  airmon-ng -> scripts/aircrack-ng/
  gobuster -> scripts/gobuster/
  ffuf -> scripts/ffuf/
  foremost -> scripts/foremost/
  dig -> scripts/dig/
  curl -> scripts/curl/
  nc -> scripts/netcat/
  netcat -> scripts/netcat/
  ncat -> scripts/netcat/
  traceroute -> scripts/traceroute/
  mtr -> scripts/traceroute/
  ```
- On detection: return JSON deny with `permissionDecisionReason` naming the specific wrapper script directory, e.g., "Blocked: direct 'nmap' call. Use wrapper scripts in scripts/nmap/ instead (e.g., bash scripts/nmap/discover-live-hosts.sh TARGET -j)"
- Also include `additionalContext` with richer structured data for Claude: the blocked tool, the full command, and the wrapper script directory

**SAFE-02 exception for curl and dig:** These tools are commonly used for non-pentesting purposes. Only intercept them when they are used with a target-like argument (an IP address or hostname that is not a well-known API/package URL). For v1, a simple approach: skip interception for curl/dig if the command contains `http://` or `https://` URLs (these are likely downloading files or hitting APIs, not pentesting). Only intercept bare `curl IP` or `dig HOSTNAME` patterns. If this is too complex, just intercept all raw curl/dig usage and document the limitation.

**SAFE-01: Target allowlist validation:**
- Read the scope file from `$CLAUDE_PROJECT_DIR/.pentest/scope.json` (use `CLAUDE_PROJECT_DIR` env var if set, else fall back to the git repo root via `git rev-parse --show-toplevel`)
- If scope file does not exist: return JSON deny with reason "No scope file found at .pentest/scope.json. Create one with {\"targets\":[\"localhost\"]} or run the health-check."
- Include `additionalContext` with structured data: `"BLOCKED: no scope file. Expected at .pentest/scope.json. Help the user create one with allowed targets."`
- Parse targets array from scope.json using jq
- Extract target from the command:
  - For wrapper scripts: target is the first positional argument after the script path. Pattern: `bash scripts/.+\.sh\s+(\S+)` — extract the first argument after `.sh`
  - For raw tool commands that passed the curl/dig exception: extract similarly
- Validate the extracted target against the scope:
  - Exact string match against each entry in `targets` array
  - For CIDR /24 entries: match if the target's first 3 octets match the CIDR's first 3 octets (simple approach, document limitation)
  - `localhost` matches `127.0.0.1` and vice versa (treat as equivalent)
- If target is NOT in scope: return JSON deny with `permissionDecisionReason`: "Target '<TARGET>' not in scope. Allowed: <comma-separated targets>. Add it to .pentest/scope.json"
- Include `additionalContext` with structured data for Claude: blocked target, current scope contents, scope file path
- If target IS in scope: exit 0 (allow, no output)

**SAFE-04: Audit logging for PreToolUse events:**
- Before returning (whether blocking or allowing), append a JSONL entry to `$PROJECT_DIR/.pentest/audit-$(date +%Y-%m-%d).jsonl`
- Create `.pentest/` directory with `mkdir -p` if it does not exist
- For blocked events: `{"timestamp":"...","event":"blocked","tool":"nmap","command":"...","target":"...","reason":"raw tool bypass","session":"$SESSION_ID"}`
- For allowed events: `{"timestamp":"...","event":"allowed","tool":"nmap","command":"...","target":"...","script":"discover-live-hosts","session":"$SESSION_ID"}`
- Extract session_id from the input JSON: `echo "$INPUT" | jq -r '.session_id // empty'`
- Extract tool name from the command for logging (the first security tool name found in the command)
- Use jq to build the JSONL entry (not string concatenation) to avoid JSON escaping issues

**Script structure order:**
1. Read stdin
2. Fast exit if not Bash
3. Fast exit if no security tool in command
4. Raw tool interception check (SAFE-02)
5. Scope file existence check
6. Target extraction
7. Target validation against scope (SAFE-01)
8. Audit logging at each exit point (SAFE-04)

Make the script executable: `chmod +x`
Use `#!/usr/bin/env bash` shebang.
  </action>
  <verify>
Test the hook manually with piped JSON input:

```bash
# Test 1: Non-security command passes through (exit 0, no output)
echo '{"tool_name":"Bash","tool_input":{"command":"git status"}}' | bash .claude/hooks/netsec-pretool.sh
# Expected: exit 0, no stdout

# Test 2: Raw nmap command is blocked
echo '{"tool_name":"Bash","tool_input":{"command":"nmap 10.0.0.1"},"session_id":"test"}' | bash .claude/hooks/netsec-pretool.sh
# Expected: JSON with permissionDecision: "deny"

# Test 3: No scope file blocks wrapper script
echo '{"tool_name":"Bash","tool_input":{"command":"bash scripts/nmap/discover-live-hosts.sh 10.0.0.1 -j"},"session_id":"test"}' | bash .claude/hooks/netsec-pretool.sh
# Expected: JSON deny mentioning scope file

# Test 4: With scope file, allowed target passes
mkdir -p .pentest && echo '{"targets":["localhost","10.0.0.1"]}' > .pentest/scope.json
echo '{"tool_name":"Bash","tool_input":{"command":"bash scripts/nmap/discover-live-hosts.sh 10.0.0.1 -j"},"session_id":"test"}' | bash .claude/hooks/netsec-pretool.sh
# Expected: exit 0, no stdout

# Test 5: With scope file, disallowed target is blocked
echo '{"tool_name":"Bash","tool_input":{"command":"bash scripts/nmap/discover-live-hosts.sh 192.168.1.1 -j"},"session_id":"test"}' | bash .claude/hooks/netsec-pretool.sh
# Expected: JSON deny mentioning target not in scope

# Clean up test scope
rm -f .pentest/scope.json && rmdir .pentest 2>/dev/null

# Verify file is executable
test -x .claude/hooks/netsec-pretool.sh && echo "PASS: executable" || echo "FAIL: not executable"
```
  </verify>
  <done>
PreToolUse hook blocks raw tool commands with redirect to wrapper scripts (SAFE-02), blocks commands targeting IPs not in scope.json (SAFE-01), allows non-security commands with zero processing, and logs blocked/allowed decisions to audit JSONL (SAFE-04 partial).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PostToolUse hook, register both hooks in settings.json, and gitignore .pentest/</name>
  <files>.claude/hooks/netsec-posttool.sh, .claude/settings.json, .gitignore</files>
  <action>
**PostToolUse hook (.claude/hooks/netsec-posttool.sh):**

Create `.claude/hooks/netsec-posttool.sh` (executable) implementing the PostToolUse hook.

**Input handling:**
- Read full JSON from stdin: `INPUT=$(cat)`
- Extract `tool_name` and `tool_input.command` using jq
- Fast exit: if `tool_name` is not "Bash", exit 0
- Fast exit: if command does not contain `scripts/`, exit 0 (only process wrapper script invocations)

**SAFE-04: Audit logging for executed commands:**
- Determine project dir: use `$CLAUDE_PROJECT_DIR` if set, else `git rev-parse --show-toplevel`
- Create audit directory: `mkdir -p "$PROJECT_DIR/.pentest"`
- Build audit JSONL entry with jq:
  - `timestamp`: ISO 8601 UTC via `date -u '+%Y-%m-%dT%H:%M:%SZ'`
  - `event`: "executed"
  - `session`: from input JSON `.session_id`
  - `command`: from `.tool_input.command`
  - `tool`: extract tool name from script path (e.g., `scripts/nmap/...` -> "nmap")
  - `target`: extract from command (first arg after `.sh`)
  - `script`: extract script name from path (e.g., `discover-live-hosts`)
  - `exit_code`: from `.tool_response.exit_code` (NOTE: this field needs validation — if it does not exist in the input, log "unknown" and continue)
  - If JSON envelope detected (see below): also include `results_total`, `results_ok`, `results_fail`
- Append to `$PROJECT_DIR/.pentest/audit-$(date +%Y-%m-%d).jsonl`

**SAFE-03: JSON bridge (additionalContext injection):**
- Extract stdout from `.tool_response.stdout` (this field needs validation — if the field path differs, the hook should gracefully degrade by skipping the JSON bridge and only doing audit logging)
- Check if the command contains `-j` flag AND the stdout is valid JSON containing the netsec envelope structure (`.meta.tool` and `.results` and `.summary` fields)
- If envelope detected, parse it and build a one-line summary:
  ```
  "Netsec result: TOOL (SCRIPT) against TARGET in MODE mode. TOTAL items: OK succeeded, FAIL failed."
  ```
- Return JSON on stdout:
  ```json
  {
    "hookSpecificOutput": {
      "hookEventName": "PostToolUse",
      "additionalContext": "Netsec result: nmap (discover-live-hosts) against localhost in execute mode. 10 items: 8 succeeded, 2 failed."
    }
  }
  ```
- If no JSON envelope detected (command was not `-j` or output is not the expected format): just do audit logging and exit 0 with no output

**Script structure order:**
1. Read stdin
2. Fast exit if not Bash
3. Fast exit if command does not contain `scripts/`
4. Extract metadata (tool name, script name, target from command)
5. Extract tool_response fields (gracefully handle missing fields)
6. Detect and parse JSON envelope if present (SAFE-03)
7. Build and append audit log entry (SAFE-04)
8. Output additionalContext JSON if envelope was parsed

Make executable: `chmod +x`
Use `#!/usr/bin/env bash` shebang.

**Settings.json update (.claude/settings.json):**

Read the existing settings.json and add PreToolUse and PostToolUse entries to the `hooks` object. Preserve the existing SessionStart hook. The result should look like:

```json
{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  },
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node .claude/hooks/gsd-check-update.js"
          }
        ]
      }
    ],
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "bash \"$CLAUDE_PROJECT_DIR/.claude/hooks/netsec-pretool.sh\""
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "bash \"$CLAUDE_PROJECT_DIR/.claude/hooks/netsec-posttool.sh\""
          }
        ]
      }
    ]
  },
  "statusLine": {
    "type": "command",
    "command": "node .claude/hooks/gsd-statusline.js"
  }
}
```

Note: Use `bash "$CLAUDE_PROJECT_DIR/.claude/hooks/..."` pattern (not direct execution) to ensure the correct working directory and avoid PATH issues. The `$CLAUDE_PROJECT_DIR` env var is automatically available in hook execution context.

**.gitignore update:**

Append `.pentest/` to the end of the `.gitignore` file with a comment header:
```
# Pentest scope and audit data
.pentest/
```
  </action>
  <verify>
Test the PostToolUse hook manually:

```bash
# Test 1: Non-script command fast exits
echo '{"tool_name":"Bash","tool_input":{"command":"git status"},"tool_response":{"stdout":"","exit_code":0}}' | bash .claude/hooks/netsec-posttool.sh
# Expected: exit 0, no stdout

# Test 2: Script invocation with JSON envelope produces additionalContext
ENVELOPE='{"meta":{"tool":"nmap","script":"discover-live-hosts","target":"localhost","category":"","started":"2026-02-17T10:00:00Z","finished":"2026-02-17T10:00:05Z","mode":"execute"},"results":[],"summary":{"total":5,"succeeded":4,"failed":1}}'
echo "{\"tool_name\":\"Bash\",\"tool_input\":{\"command\":\"bash scripts/nmap/discover-live-hosts.sh localhost -j -x\"},\"tool_response\":{\"stdout\":$(echo "$ENVELOPE" | jq -Rs .),\"exit_code\":0},\"session_id\":\"test\"}" | bash .claude/hooks/netsec-posttool.sh
# Expected: JSON with additionalContext containing "Netsec result: nmap (discover-live-hosts)..."

# Test 3: Script invocation without -j just logs audit, no output
echo '{"tool_name":"Bash","tool_input":{"command":"bash scripts/nmap/discover-live-hosts.sh localhost"},"tool_response":{"stdout":"some output","exit_code":0},"session_id":"test"}' | bash .claude/hooks/netsec-posttool.sh
# Expected: exit 0, no stdout, but audit log entry created

# Test 4: Verify audit log was created
ls .pentest/audit-$(date +%Y-%m-%d).jsonl 2>/dev/null && echo "PASS: audit file exists" || echo "FAIL: no audit file"
cat .pentest/audit-$(date +%Y-%m-%d).jsonl 2>/dev/null | jq . | head -5

# Clean up
rm -rf .pentest/

# Verify settings.json is valid JSON with both hooks
jq -e '.hooks.PreToolUse[0].hooks[0].command' .claude/settings.json && echo "PASS: PreToolUse registered"
jq -e '.hooks.PostToolUse[0].hooks[0].command' .claude/settings.json && echo "PASS: PostToolUse registered"
jq -e '.hooks.SessionStart' .claude/settings.json && echo "PASS: SessionStart preserved"

# Verify .gitignore contains .pentest/
grep -q '.pentest/' .gitignore && echo "PASS: .pentest/ gitignored" || echo "FAIL: not gitignored"

# Verify both hooks are executable
test -x .claude/hooks/netsec-pretool.sh && echo "PASS: pretool executable"
test -x .claude/hooks/netsec-posttool.sh && echo "PASS: posttool executable"
```
  </verify>
  <done>
PostToolUse hook parses JSON envelope output from -j scripts and injects a one-line summary as additionalContext (SAFE-03). Both PreToolUse and PostToolUse hooks log all events to date-stamped JSONL audit files (SAFE-04). Both hooks are registered in settings.json with Bash matcher. .pentest/ is gitignored.
  </done>
</task>

</tasks>

<verification>
1. Non-security Bash commands (git, ls, npm, node) produce zero hook output and no latency
2. Raw tool invocations (e.g., `nmap 10.0.0.1`) are denied with redirect to wrapper scripts
3. Wrapper script invocations against out-of-scope targets are denied with scope info
4. Wrapper script invocations against in-scope targets are allowed
5. JSON envelope output from -j scripts produces additionalContext for Claude
6. All security-tool events (blocked, allowed, executed) appear in .pentest/audit-YYYY-MM-DD.jsonl
7. settings.json has PreToolUse and PostToolUse hook registrations alongside existing SessionStart
8. .pentest/ is in .gitignore
</verification>

<success_criteria>
- Both hook scripts exist, are executable, and pass manual pipe tests
- settings.json registers both hooks with Bash matcher
- .pentest/ is gitignored
- No modifications to any existing scripts (plugin wraps, never modifies)
</success_criteria>

<output>
After completion, create `.planning/phases/28-safety-architecture/28-01-SUMMARY.md`
</output>
