---
phase: 32-workflow-skills
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .claude/skills/fuzz/SKILL.md
  - .claude/skills/crack/SKILL.md
  - .claude/skills/sniff/SKILL.md
autonomous: true
requirements: [WKFL-04, WKFL-05, WKFL-06]

must_haves:
  truths:
    - "User can invoke /fuzz and Claude receives instructions to run gobuster directory discovery, ffuf parameter fuzzing, and nikto vulnerability scanning"
    - "User can invoke /crack and Claude receives instructions to identify hash type first, then crack with hashcat or john depending on hash type"
    - "User can invoke /sniff and Claude receives instructions to capture HTTP credentials, analyze DNS queries, and extract files from captures"
    - "All 3 skills have disable-model-invocation: true in frontmatter"
    - "All 3 skills include scope/argument handling appropriate to their domain"
    - "/crack handles the offline-tool distinction (operates on local hash files, not network targets)"
  artifacts:
    - path: ".claude/skills/fuzz/SKILL.md"
      provides: "Fuzzing workflow orchestrating 3 scripts across gobuster, ffuf, nikto"
      contains: "disable-model-invocation: true"
    - path: ".claude/skills/crack/SKILL.md"
      provides: "Password cracking workflow orchestrating 5 scripts across john, hashcat"
      contains: "disable-model-invocation: true"
    - path: ".claude/skills/sniff/SKILL.md"
      provides: "Traffic capture workflow orchestrating 3 tshark scripts"
      contains: "disable-model-invocation: true"
  key_links:
    - from: ".claude/skills/fuzz/SKILL.md"
      to: "scripts/gobuster/discover-directories.sh, scripts/ffuf/fuzz-parameters.sh, scripts/nikto/scan-specific-vulnerabilities.sh"
      via: "bash script references in numbered steps"
      pattern: "bash scripts/(gobuster|ffuf|nikto)/"
    - from: ".claude/skills/crack/SKILL.md"
      to: "scripts/john/identify-hash-type.sh, scripts/hashcat/crack-ntlm-hashes.sh, scripts/hashcat/crack-web-hashes.sh, scripts/john/crack-linux-passwords.sh, scripts/john/crack-archive-passwords.sh"
      via: "bash script references in numbered steps"
      pattern: "bash scripts/(john|hashcat)/"
    - from: ".claude/skills/sniff/SKILL.md"
      to: "scripts/tshark/capture-http-credentials.sh, scripts/tshark/analyze-dns-queries.sh, scripts/tshark/extract-files-from-capture.sh"
      via: "bash script references in numbered steps"
      pattern: "bash scripts/tshark/"
---

<objective>
Create 3 specialized offensive workflow skills (/fuzz, /crack, /sniff) that instruct Claude to orchestrate domain-specific multi-tool pentesting workflows.

Purpose: Each workflow targets a distinct offensive domain -- web fuzzing, password cracking, and traffic capture. /crack is notable because it operates on local files (hash files, archives) rather than network targets, requiring different scope handling.

Output: 3 SKILL.md files in `.claude/skills/{fuzz,crack,sniff}/SKILL.md`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-workflow-skills/32-RESEARCH.md
@.claude/skills/nmap/SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /fuzz and /sniff workflow skills</name>
  <files>.claude/skills/fuzz/SKILL.md, .claude/skills/sniff/SKILL.md</files>
  <action>
Create SKILL.md for /fuzz and /sniff workflows. Both are network-oriented workflows that use standard -j -x flags on all scripts.

**fuzz** (`.claude/skills/fuzz/SKILL.md`):
- Frontmatter: name: fuzz, description: "Run fuzzing workflow -- directory brute-force, parameter fuzzing, and web scanning", argument-hint: "&lt;target-url&gt;", disable-model-invocation: true
- H1: "Fuzzing Workflow"
- Purpose line: "Run web fuzzing and enumeration against the target URL."
- Target section: "Target: $ARGUMENTS" with guard. Note that fuzzing targets are typically URLs (e.g., http://localhost:8080). "If no target was provided, ask the user for a target URL. Verify the host portion is in `.pentest/scope.json`."
- Steps section with 3 numbered steps:
  1. Directory Discovery: `bash scripts/gobuster/discover-directories.sh $ARGUMENTS -j -x` -- "Brute-force discover hidden directories and files on the web server."
  2. Parameter Fuzzing: `bash scripts/ffuf/fuzz-parameters.sh $ARGUMENTS -j -x` -- "Fuzz URL parameters, headers, and request bodies for hidden inputs."
  3. Web Vulnerability Scan: `bash scripts/nikto/scan-specific-vulnerabilities.sh $ARGUMENTS -j -x` -- "Scan for known web server vulnerabilities, misconfigurations, and dangerous files."
- "After Each Step" section: review findings, note discovered paths/parameters, adapt subsequent steps
- Summary section: organized by category (Discovered Paths, Parameters Found, Vulnerabilities)

**sniff** (`.claude/skills/sniff/SKILL.md`):
- Frontmatter: name: sniff, description: "Run traffic capture and analysis workflow -- HTTP credentials, DNS queries, and file extraction", argument-hint: "&lt;interface-or-capture-file&gt;", disable-model-invocation: true
- H1: "Traffic Capture & Analysis Workflow"
- Purpose line: "Capture and analyze network traffic for credentials, DNS activity, and file transfers."
- Target section: "Target: $ARGUMENTS" with guard. Note that $ARGUMENTS can be a network interface (e.g., eth0, lo0) for live capture or a .pcap file for analysis. "If no target was provided, ask the user whether to capture live traffic (provide interface) or analyze an existing capture file."
- Steps section with 3 numbered steps:
  1. HTTP Credential Capture: `bash scripts/tshark/capture-http-credentials.sh $ARGUMENTS -j -x` -- "Capture HTTP authentication headers, form submissions, and cookie exchanges."
  2. DNS Query Analysis: `bash scripts/tshark/analyze-dns-queries.sh $ARGUMENTS -j -x` -- "Analyze DNS query patterns, unusual lookups, and potential data exfiltration via DNS."
  3. File Extraction: `bash scripts/tshark/extract-files-from-capture.sh $ARGUMENTS -j -x` -- "Extract transferred files (HTTP downloads, email attachments) from captured traffic."
- "After Each Step" section: review findings, note credentials/queries/files discovered
- Important note: "Live capture may require root privileges. If permission denied, suggest running with sudo."
- Summary section: organized by category (Credentials, DNS Activity, Extracted Files)

Keep each skill under 200 lines. All script references MUST include -j -x flags.
  </action>
  <verify>
Verify both files exist and have correct structure:
- `head -5 .claude/skills/fuzz/SKILL.md` shows YAML frontmatter with disable-model-invocation: true
- `head -5 .claude/skills/sniff/SKILL.md` shows YAML frontmatter with disable-model-invocation: true
- `grep -c 'bash scripts/' .claude/skills/fuzz/SKILL.md` returns 3
- `grep -c 'bash scripts/' .claude/skills/sniff/SKILL.md` returns 3
- `grep -c '\-j \-x' .claude/skills/fuzz/SKILL.md` returns 3
- `grep -c '\-j \-x' .claude/skills/sniff/SKILL.md` returns 3
- `grep '$ARGUMENTS' .claude/skills/fuzz/SKILL.md .claude/skills/sniff/SKILL.md` shows both use argument substitution
  </verify>
  <done>fuzz and sniff SKILL.md files exist with numbered steps, correct script paths, -j -x flags, scope checking, and structured summaries</done>
</task>

<task type="auto">
  <name>Task 2: Create /crack workflow skill</name>
  <files>.claude/skills/crack/SKILL.md</files>
  <action>
Create SKILL.md for /crack workflow. This is an OFFLINE workflow -- it operates on local hash files and archives, not network targets. The scope handling is different: no network scope validation needed, but the user still needs to provide a hash file or hash string as input.

**crack** (`.claude/skills/crack/SKILL.md`):
- Frontmatter: name: crack, description: "Run password cracking workflow -- hash identification, dictionary attacks, and brute force", argument-hint: "&lt;hashfile-or-hash&gt;", disable-model-invocation: true
- H1: "Password Cracking Workflow"
- Purpose line: "Identify and crack password hashes using multiple tools and techniques."
- Target section: "Target: $ARGUMENTS" with guard. "If no input was provided, ask the user for a hash file path or hash string. This workflow operates on local files -- no network scope validation needed."
- Steps section with 5 numbered steps that follow a logical identification-then-attack flow:
  1. Hash Identification: `bash scripts/john/identify-hash-type.sh $ARGUMENTS -j -x` -- "Identify the hash algorithm(s) before attempting to crack. This determines which subsequent tools and modes to use."
  2. NTLM Cracking (if applicable): `bash scripts/hashcat/crack-ntlm-hashes.sh $ARGUMENTS -j -x` -- "If hashes are identified as NTLM (Windows), use GPU-accelerated hashcat. Skip if not NTLM."
  3. Web Hash Cracking (if applicable): `bash scripts/hashcat/crack-web-hashes.sh $ARGUMENTS -j -x` -- "If hashes are MD5, SHA-256, bcrypt, WordPress, Django, or MySQL types. Skip if not a web hash type."
  4. Linux Password Cracking (if applicable): `bash scripts/john/crack-linux-passwords.sh -j -x` -- "If hashes are from /etc/shadow or similar Linux password stores. Note: this script does not take a positional argument (it handles /etc/shadow internally). Skip if not Linux hashes."
  5. Archive Cracking (if applicable): `bash scripts/john/crack-archive-passwords.sh $ARGUMENTS -j -x` -- "If the target is a password-protected ZIP, RAR, 7z, or PDF file. Skip if not an archive."
- "After Each Step" section: review cracking results, note recovered passwords, determine if additional tools/modes are worth trying
- Decision guidance: "Based on the hash type identified in Step 1, run only the relevant cracking steps (2-5). Do not run all steps blindly. If the hash type is ambiguous, try multiple approaches."
- Summary section: organized by results (Hash Types Identified, Passwords Recovered, Failed Attempts, Recommendations)

Keep under 200 lines. Note that Step 4 (john/crack-linux-passwords.sh) takes NO positional argument.
  </action>
  <verify>
Verify the file exists and correctly handles offline tool workflow:
- `head -5 .claude/skills/crack/SKILL.md` shows YAML frontmatter with disable-model-invocation: true
- `grep -c 'bash scripts/' .claude/skills/crack/SKILL.md` returns 5
- `grep -c '\-j \-x' .claude/skills/crack/SKILL.md` returns 5
- `grep 'crack-linux-passwords' .claude/skills/crack/SKILL.md` confirms no positional argument on that script
- `grep -i 'no network scope\|local files\|offline' .claude/skills/crack/SKILL.md` confirms offline tool distinction
- `grep '$ARGUMENTS' .claude/skills/crack/SKILL.md` confirms argument substitution
  </verify>
  <done>crack SKILL.md exists with 5 steps following identification-then-attack flow, offline scope handling, conditional step guidance, and correct per-script argument patterns</done>
</task>

</tasks>

<verification>
- All 3 files exist: `.claude/skills/{fuzz,crack,sniff}/SKILL.md`
- All 3 have `disable-model-invocation: true` in frontmatter
- /fuzz references 3 scripts (gobuster x1, ffuf x1, nikto x1) -- all with -j -x
- /crack references 5 scripts (john x3, hashcat x2) -- all with -j -x, conditional execution based on hash type
- /sniff references 3 scripts (tshark x3) -- all with -j -x
- /crack correctly notes offline operation (no network scope needed)
- /sniff mentions root privilege requirement for live capture
- All skills include argument handling and structured summaries
- No skill exceeds 200 lines
</verification>

<success_criteria>
- 3 workflow SKILL.md files created for /fuzz, /crack, /sniff
- Each skill has numbered orchestration steps with correct script paths and flags
- /crack correctly handles offline scope (local files, not network targets)
- /crack follows identification-then-attack flow (identify hash type first)
- /sniff handles both live capture and pcap file analysis
- All use disable-model-invocation: true
</success_criteria>

<output>
After completion, create `.planning/phases/32-workflow-skills/32-02-SUMMARY.md`
</output>
