---
phase: 25-script-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/json.sh
  - scripts/dig/query-dns-records.sh
  - scripts/ffuf/fuzz-parameters.sh
  - scripts/nmap/discover-live-hosts.sh
  - scripts/nmap/scan-web-vulnerabilities.sh
  - scripts/nikto/scan-specific-vulnerabilities.sh
  - scripts/skipfish/quick-scan-web-app.sh
  - scripts/skipfish/scan-authenticated-app.sh
  - scripts/sqlmap/bypass-waf.sh
  - scripts/sqlmap/test-all-parameters.sh
  - scripts/traceroute/diagnose-latency.sh
  - scripts/traceroute/trace-network-path.sh
autonomous: true

must_haves:
  truths:
    - "json_set_meta accepts a third 'category' parameter and includes it in the JSON envelope"
    - "Existing BATS tests still pass after the library change (backward compatible)"
    - "All 11 Group A scripts call json_set_meta with correct tool, target, and category"
    - "All 11 Group A scripts call json_finalize before the interactive demo block"
  artifacts:
    - path: "scripts/lib/json.sh"
      provides: "Extended json_set_meta with category parameter"
      contains: "_JSON_CATEGORY"
    - path: "scripts/dig/query-dns-records.sh"
      provides: "JSON support via json_set_meta and json_finalize"
      contains: "json_set_meta"
    - path: "scripts/nmap/discover-live-hosts.sh"
      provides: "JSON support via json_set_meta and json_finalize"
      contains: "json_set_meta"
  key_links:
    - from: "scripts/*/use-case.sh"
      to: "scripts/lib/json.sh"
      via: "json_set_meta and json_finalize calls"
      pattern: 'json_set_meta "\w+" "\$\w+" "\w+-?\w+"'
---

<objective>
Extend json_set_meta to accept a category parameter and migrate all 11 Group A scripts (pure run_or_show) to produce JSON output.

Purpose: Establishes the foundation for all script migrations by adding the category field to the JSON API, then applies the minimal 2-line migration pattern to the 11 simplest scripts.
Output: Updated lib/json.sh with category support; 11 scripts producing valid JSON with correct meta fields when invoked with `-j`.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-script-migration/25-RESEARCH.md
@scripts/lib/json.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend json_set_meta with category parameter</name>
  <files>scripts/lib/json.sh</files>
  <action>
Add `_JSON_CATEGORY=""` to the state variables section (alongside `_JSON_TOOL`, `_JSON_TARGET`, etc.).

Update `json_set_meta()` to accept a third optional parameter:
```bash
json_set_meta() {
    json_is_active || return 0
    _JSON_TOOL="$1"
    _JSON_TARGET="${2:-}"
    _JSON_CATEGORY="${3:-}"
    _JSON_SCRIPT="$(basename "${BASH_SOURCE[1]:-unknown}" .sh)"
    _JSON_STARTED="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
}
```

Update `json_finalize()` to include category in the envelope. Add `--arg category "$_JSON_CATEGORY"` to the jq call and add `category: $category` to the meta object after the `target` field.

The third parameter MUST be optional (defaulting to empty string) so existing callers (including Phase 24 tests that call `json_set_meta "tool" "target"`) continue to work without modification.

Update the function's usage comment from `# Usage: json_set_meta "tool" "target"` to `# Usage: json_set_meta "tool" "target" ["category"]`.
  </action>
  <verify>
Run `bats tests/lib-json.bats` — all existing tests must pass (backward compatibility).
Run `bats tests/lib-output.bats` — all existing tests must pass.
Run `bats tests/lib-args.bats` — all existing tests must pass.
Manually verify: `grep '_JSON_CATEGORY' scripts/lib/json.sh` shows the new state variable and its use in json_set_meta and json_finalize.
  </verify>
  <done>json_set_meta accepts 3 arguments; json_finalize includes category in the meta object; all existing BATS tests pass unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate 11 Group A scripts (pure run_or_show)</name>
  <files>
scripts/dig/query-dns-records.sh
scripts/ffuf/fuzz-parameters.sh
scripts/nmap/discover-live-hosts.sh
scripts/nmap/scan-web-vulnerabilities.sh
scripts/nikto/scan-specific-vulnerabilities.sh
scripts/skipfish/quick-scan-web-app.sh
scripts/skipfish/scan-authenticated-app.sh
scripts/sqlmap/bypass-waf.sh
scripts/sqlmap/test-all-parameters.sh
scripts/traceroute/diagnose-latency.sh
scripts/traceroute/trace-network-path.sh
  </files>
  <action>
For each of the 11 scripts, add exactly 2 lines:

1. **json_set_meta line** — placed AFTER the TARGET variable assignment and BEFORE `confirm_execute`. Use the correct tool name, target variable, and category from this mapping:

| Script | Tool | Target Var | Category |
|--------|------|-----------|----------|
| dig/query-dns-records.sh | dig | $TARGET | network-analysis |
| ffuf/fuzz-parameters.sh | ffuf | $TARGET | web-scanner |
| nmap/discover-live-hosts.sh | nmap | $TARGET | network-scanner |
| nmap/scan-web-vulnerabilities.sh | nmap | $TARGET | network-scanner |
| nikto/scan-specific-vulnerabilities.sh | nikto | $TARGET | web-scanner |
| skipfish/quick-scan-web-app.sh | skipfish | $TARGET | web-scanner |
| skipfish/scan-authenticated-app.sh | skipfish | $TARGET | web-scanner |
| sqlmap/bypass-waf.sh | sqlmap | $TARGET | sql-injection |
| sqlmap/test-all-parameters.sh | sqlmap | $TARGET | sql-injection |
| traceroute/diagnose-latency.sh | traceroute | $TARGET | network-analysis |
| traceroute/trace-network-path.sh | traceroute | $TARGET | network-analysis |

Example insertion:
```bash
TARGET="${1:-example.com}"

json_set_meta "dig" "$TARGET" "network-analysis"

confirm_execute "${1:-}"
```

2. **json_finalize line** — placed BEFORE the interactive demo block. The demo block starts with `if [[ "${EXECUTE_MODE:-show}" == "show" ]]; then` followed by `[[ ! -t 0 ]] && exit 0`. Place `json_finalize` on the blank line immediately before this `if` block.

Example:
```bash
run_or_show "10) Query via specific DNS server (Cloudflare)" \
    dig @1.1.1.1 "$TARGET" A +noall +answer

json_finalize

# Interactive demo (skip if non-interactive)
if [[ "${EXECUTE_MODE:-show}" == "show" ]]; then
```

Note: Some Group A scripts have 1 bare info+echo example (skipfish, sqlmap, traceroute). For those, also add a `json_add_example` call after the bare `echo` line, using the same description as the `info` call and the command string from the `echo` line.

No other changes needed — `run_or_show` already captures commands as JSON results automatically via the library hook in output.sh.
  </action>
  <verify>
For each script, verify it produces valid JSON:
```bash
bash scripts/dig/query-dns-records.sh -j example.com 3>&1 1>/dev/null 2>/dev/null | jq -e '.meta.tool and .meta.category and .meta.target'
```
Run `grep -r 'json_set_meta' scripts/ --include='*.sh' | grep -v lib/ | wc -l` — should show 11 scripts.
Run `grep -r 'json_finalize' scripts/ --include='*.sh' | grep -v lib/ | wc -l` — should show 11 scripts.
  </verify>
  <done>All 11 Group A scripts contain json_set_meta with correct tool/target/category and json_finalize before the interactive demo block. Each produces valid JSON when invoked with -j.</done>
</task>

</tasks>

<verification>
1. `bats tests/lib-json.bats && bats tests/lib-output.bats && bats tests/lib-args.bats` — all existing tests pass
2. `grep -c '_JSON_CATEGORY' scripts/lib/json.sh` — returns at least 3 (declaration, set_meta, finalize)
3. `grep -r 'json_set_meta' scripts/ --include='*.sh' | grep -v lib/ | wc -l` — returns 11
4. `grep -r 'json_finalize' scripts/ --include='*.sh' | grep -v lib/ | wc -l` — returns 11
5. Spot-check 2-3 scripts with `-j` flag produce valid JSON via `jq .`
</verification>

<success_criteria>
- json_set_meta accepts 3 args with category as optional third parameter
- json_finalize includes category in the meta object
- All existing BATS tests pass unchanged
- All 11 Group A scripts have json_set_meta and json_finalize
- Each Group A script's json_set_meta uses the correct tool, target variable, and category string
</success_criteria>

<output>
After completion, create `.planning/phases/25-script-migration/25-01-SUMMARY.md`
</output>
