---
phase: 03-diagnostic-scripts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/diagnostics/dns.sh
  - Makefile
autonomous: true

must_haves:
  truths:
    - "Running `make diagnose-dns TARGET=example.com` produces a structured DNS report"
    - "Report has sections for resolution, record types, propagation, and reverse DNS"
    - "Each check shows [PASS], [FAIL], or [WARN] indicator"
    - "Script runs non-interactively (no prompts, completes on its own)"
    - "Script works on macOS and Linux (no platform-specific failures)"
  artifacts:
    - path: "scripts/diagnostics/dns.sh"
      provides: "DNS diagnostic auto-report (Pattern B)"
      min_lines: 100
      contains: "report_section"
    - path: "Makefile"
      provides: "diagnose-dns target"
      contains: "diagnose-dns"
  key_links:
    - from: "scripts/diagnostics/dns.sh"
      to: "scripts/common.sh"
      via: "source directive"
      pattern: 'source.*common\.sh'
    - from: "scripts/diagnostics/dns.sh"
      to: "dig"
      via: "require_cmd"
      pattern: "require_cmd dig"
    - from: "scripts/diagnostics/dns.sh"
      to: "report output"
      via: "report_pass/fail/warn and report_section calls"
      pattern: "report_(pass|fail|warn|section)"
    - from: "Makefile"
      to: "scripts/diagnostics/dns.sh"
      via: "diagnose-dns target"
      pattern: "diagnose-dns.*diagnostics/dns.sh"
---

<objective>
Create the DNS diagnostic auto-report script that establishes Pattern B for all future diagnostic scripts. When run, it queries the target domain across multiple check categories (resolution, record types, propagation, reverse DNS) and produces a structured report with [PASS]/[FAIL]/[WARN] indicators using the common.sh report functions built in Phase 1.

Purpose: This is the first diagnostic script and establishes the canonical Pattern B template that connectivity.sh (Plan 02) and future diagnostics (Phase 5 performance.sh) will follow.
Output: `scripts/diagnostics/dns.sh` executable script + `diagnose-dns` Makefile target.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-diagnostic-scripts/03-RESEARCH.md
@scripts/common.sh
@Makefile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DNS diagnostic script (scripts/diagnostics/dns.sh)</name>
  <files>scripts/diagnostics/dns.sh</files>
  <action>
Create the directory `scripts/diagnostics/` and the file `scripts/diagnostics/dns.sh`. Make it executable (`chmod +x`).

Follow the Pattern B template from the research. Structure:

1. **Preamble:** `#!/usr/bin/env bash`, description comment, `source "$(dirname "$0")/../common.sh"`, `show_help()` function, help flag check, `require_cmd dig` with install hint covering apt/dnf/brew. Target defaults to `example.com`. NO `safety_banner` (diagnostics are passive/read-only). Instead use `info "=== DNS Diagnostic Report ==="` header with target and date.

2. **Counter variables:** Define `PASS_COUNT=0`, `FAIL_COUNT=0`, `WARN_COUNT=0` at script level. Create wrapper functions `count_pass()`, `count_fail()`, `count_warn()` that call `report_pass`/`report_fail`/`report_warn` AND increment the counter. Use these wrappers throughout instead of calling report_* directly.

3. **Section 1 — DNS Resolution:** Use `report_section "DNS Resolution"`. Custom check function for A record (pass if IP returned, fail if empty). Custom check for AAAA record (pass if exists, WARN if missing — not fail, since many domains lack IPv6). Check CNAME for `www.${TARGET}`.

4. **Section 2 — DNS Record Types:** Use `report_section "DNS Record Types"`. Check MX records (pass if found, warn if empty — not all domains have MX). Check NS records (pass/fail — every domain should have NS). Check TXT records (pass if found, warn if empty). Check SOA record (pass/fail — every domain should have SOA).

5. **Section 3 — DNS Propagation:** Use `report_section "DNS Propagation"`. Define resolver arrays at top of script: `RESOLVERS=("8.8.8.8" "1.1.1.1" "9.9.9.9" "208.67.222.222")` and `RESOLVER_NAMES=("Google" "Cloudflare" "Quad9" "OpenDNS")`. Query each resolver for A record, collect results, report pass/warn per resolver. After all queries, check consistency — if all resolvers agree, report pass; if they differ, report warn about propagation in progress.

6. **Section 4 — Reverse DNS:** Use `report_section "Reverse DNS"`. Resolve the A record IP, then do `dig -x <IP> +short` for PTR lookup. Pass if PTR record exists, warn if no reverse DNS (common but not critical).

7. **Section 5 — Summary:** Use `report_section "Summary"`. Print `PASS_COUNT passed, FAIL_COUNT failed, WARN_COUNT warnings`. If FAIL_COUNT > 0, use `report_fail` for the summary line. If WARN_COUNT > 0 but no failures, use `report_warn`. If all pass, use `report_pass`.

Key implementation details:
- Use `dig +short` for machine-parseable output in checks.
- Use `dig +noall +answer` when showing detailed records to the user (indented with `echo "   ..."` pattern).
- All dig calls should redirect stderr: `2>/dev/null`.
- Use `run_check` ONLY for simple binary pass/fail checks. For nuanced checks needing WARN, write custom check functions.
- Do NOT use `grep -P` (BSD incompatible). Use `grep -E` or `awk`.
- Do NOT use `safety_banner`.
- Script must be fully non-interactive — no `read` prompts, no `[[ ! -t 0 ]]` check.
  </action>
  <verify>
Run `bash scripts/diagnostics/dns.sh` (default target example.com) and confirm:
- Header shows target and date
- 4 sections appear with === markers
- Individual checks show [PASS], [FAIL], or [WARN]
- Summary shows pass/fail/warn counts
- Script exits without prompting for input
- Run `bash scripts/diagnostics/dns.sh --help` shows usage
  </verify>
  <done>
dns.sh produces a structured report with 4 sections (Resolution, Record Types, Propagation, Reverse DNS) plus Summary, each check has colored [PASS]/[FAIL]/[WARN] indicators, script runs non-interactively, and `--help` works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add diagnose-dns Makefile target</name>
  <files>Makefile</files>
  <action>
Add the `diagnose-dns` target to the Makefile. Place it after the site targets section and before the tool-specific runners, in a new "Diagnostic targets" comment section.

Add to `.PHONY` line: `diagnose-dns`

Add the target:
```makefile
# Diagnostic targets
diagnose-dns: ## Run DNS diagnostic (usage: make diagnose-dns TARGET=<domain>)
	@bash scripts/diagnostics/dns.sh $(or $(TARGET),example.com)
```

Follow the existing convention: `$(or $(TARGET),example.com)` provides the sensible default. Use `@bash` prefix to suppress command echo. The `##` comment enables `make help` detection.
  </action>
  <verify>
Run `make diagnose-dns` and confirm it produces the DNS diagnostic report for example.com. Run `make diagnose-dns TARGET=google.com` and confirm it targets google.com. Run `make help` and confirm `diagnose-dns` appears in the help output.
  </verify>
  <done>
`make diagnose-dns` runs dns.sh with default target, `make diagnose-dns TARGET=<domain>` passes custom target, and `make help` lists the new target.
  </done>
</task>

</tasks>

<verification>
1. `bash scripts/diagnostics/dns.sh` completes without errors and produces structured output
2. `bash scripts/diagnostics/dns.sh --help` shows usage information
3. `bash scripts/diagnostics/dns.sh google.com` works with custom target
4. `make diagnose-dns` works via Makefile
5. `make help` shows `diagnose-dns` in the target list
6. Output contains [PASS], [FAIL], or [WARN] indicators
7. Output contains section headers (===)
8. Script does not prompt for input (non-interactive)
</verification>

<success_criteria>
- DNS diagnostic script exists at scripts/diagnostics/dns.sh and is executable
- Running it produces a 4-section structured report with pass/fail/warn indicators and a summary
- Makefile target `diagnose-dns` works with default and custom TARGET
- Pattern B template is established for Plan 02 to follow
</success_criteria>

<output>
After completion, create `.planning/phases/03-diagnostic-scripts/03-01-SUMMARY.md`
</output>
