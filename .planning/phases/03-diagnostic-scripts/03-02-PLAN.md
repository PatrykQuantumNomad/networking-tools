---
phase: 03-diagnostic-scripts
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - scripts/diagnostics/connectivity.sh
  - Makefile
  - USECASES.md
autonomous: true

must_haves:
  truths:
    - "Running `make diagnose-connectivity TARGET=example.com` produces a structured connectivity report"
    - "Report walks through DNS -> ICMP -> TCP -> HTTP -> TLS -> Timing layers"
    - "Each check shows [PASS], [FAIL], or [WARN] indicator"
    - "Script runs non-interactively (no prompts, completes on its own)"
    - "Script works on macOS and Linux (ping flags, ip/ifconfig fallbacks handled)"
    - "USECASES.md has entries for both DNS and connectivity diagnostics"
  artifacts:
    - path: "scripts/diagnostics/connectivity.sh"
      provides: "Connectivity diagnostic auto-report (Pattern B)"
      min_lines: 120
      contains: "report_section"
    - path: "Makefile"
      provides: "diagnose-connectivity target"
      contains: "diagnose-connectivity"
    - path: "USECASES.md"
      provides: "Diagnostic use-case entries"
      contains: "diagnose-dns"
  key_links:
    - from: "scripts/diagnostics/connectivity.sh"
      to: "scripts/common.sh"
      via: "source directive"
      pattern: 'source.*common\.sh'
    - from: "scripts/diagnostics/connectivity.sh"
      to: "curl, dig, nc, ping"
      via: "require_cmd calls"
      pattern: "require_cmd (curl|dig)"
    - from: "scripts/diagnostics/connectivity.sh"
      to: "report output"
      via: "report_pass/fail/warn and report_section calls"
      pattern: "report_(pass|fail|warn|section)"
    - from: "scripts/diagnostics/connectivity.sh"
      to: "platform detection"
      via: "OS_TYPE variable and conditional logic"
      pattern: 'OS_TYPE.*uname'
    - from: "Makefile"
      to: "scripts/diagnostics/connectivity.sh"
      via: "diagnose-connectivity target"
      pattern: "diagnose-connectivity.*diagnostics/connectivity.sh"
---

<objective>
Create the connectivity diagnostic auto-report script following the Pattern B template established in Plan 01 (dns.sh). This script walks through network layers (DNS -> ICMP -> TCP -> HTTP -> TLS -> Timing) to diagnose connectivity issues. Also add the diagnose-connectivity Makefile target and update USECASES.md with diagnostic entries.

Purpose: Complete the diagnostic scripts pair. The connectivity script has more cross-platform concerns (ping flags, ip/ifconfig, ss/netstat) than dns.sh, making it the harder of the two.
Output: `scripts/diagnostics/connectivity.sh` + `diagnose-connectivity` Makefile target + USECASES.md update.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-diagnostic-scripts/03-RESEARCH.md
@.planning/phases/03-diagnostic-scripts/03-01-SUMMARY.md
@scripts/common.sh
@scripts/diagnostics/dns.sh
@Makefile
@USECASES.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create connectivity diagnostic script (scripts/diagnostics/connectivity.sh)</name>
  <files>scripts/diagnostics/connectivity.sh</files>
  <action>
Create `scripts/diagnostics/connectivity.sh` and make it executable. Follow the SAME Pattern B structure as dns.sh from Plan 01 (reference it for header, counter pattern, show_help, section flow).

1. **Preamble:** Same as dns.sh pattern — shebang, description, source common.sh, show_help(), help flag, require_cmd for `curl` and `dig` (with install hints). Target defaults to `example.com`. Detect OS: `OS_TYPE="$(uname -s)"`. NO `safety_banner` — use info header like dns.sh.

2. **Counter variables:** Implement the same counter pattern as dns.sh (Plan 01): Define `PASS_COUNT=0`, `FAIL_COUNT=0`, `WARN_COUNT=0` at script level. Create wrapper functions `count_pass()`, `count_fail()`, `count_warn()` that call `report_pass`/`report_fail`/`report_warn` AND increment the respective counter. Use these wrappers throughout instead of calling report_* directly.

3. **Helper functions (at top of script, after preamble):**
   - `ping_host()` — portable ping. macOS: `ping -c "$count" -t 5 "$target"`, Linux: `ping -c "$count" -w 5 "$target"`. Uses `$OS_TYPE` for branching. CRITICAL: Do NOT use `-W` flag — it means milliseconds on macOS but seconds on Linux. Use `-t`/`-w` as the overall deadline per the research.
   - `get_local_ip()` — try `ip -4 addr show scope global` first (Linux), fall back to `ifconfig | grep 'inet '` (macOS/legacy). Use `check_cmd ip` for detection. Use `awk` for parsing — do NOT use `grep -P`.
   - `get_default_gateway()` — try `ip route show default | awk '{print $3}'` (Linux), fall back to `route -n get default 2>/dev/null | grep gateway | awk '{print $2}'` on macOS, else `route -n 2>/dev/null | grep '^0.0.0.0' | awk '{print $2}'` on other Linux.
   - `strip_protocol()` — remove `http://` or `https://` prefix from TARGET for use in non-HTTP commands (dig, ping, nc). Pattern: `echo "$1" | sed -E 's|^https?://||' | sed -E 's|/.*||'`

4. **Section 1 — Local Network Info:** Use `report_section "Local Network"`. Show local IP via `get_local_ip()` and default gateway via `get_default_gateway()`. These are informational — report_pass if detected, report_warn if "unknown".

5. **Section 2 — DNS Resolution:** Use `report_section "DNS Resolution"`. Strip protocol from TARGET. Resolve the domain with `dig +short`. Pass if IP returned, fail if empty. Store the resolved IP in a variable for use in subsequent sections.

6. **Section 3 — ICMP Reachability:** Use `report_section "ICMP Reachability"`. Use `ping_host` function. Pass if ping succeeds (exit 0), warn if ping fails (ICMP may be blocked — this is warn, not fail, since many hosts block ICMP). Show ping statistics if available.

7. **Section 4 — TCP Port Connectivity:** Use `report_section "TCP Port Connectivity"`. Use `nc -z -w 3` to check ports 80 and 443 on the stripped target. Use `run_check` for these since they are binary pass/fail. If neither port is open, report_fail.

8. **Section 5 — HTTP/HTTPS Response:** Use `report_section "HTTP/HTTPS Response"`. Use curl to check HTTP (port 80) and HTTPS (port 443). For HTTP: `curl -sI -o /dev/null -w "%{http_code}" --connect-timeout 5 "http://${HOST}"` — pass if 2xx/3xx, warn if 4xx, fail if connection error. For HTTPS: same pattern with `https://`. Custom check functions needed for the status code interpretation.

9. **Section 6 — TLS Certificate:** Use `report_section "TLS Certificate"`. Use `curl -vI "https://${HOST}" 2>&1` and parse for cert info. Check certificate expiry — extract `expire date` from curl verbose output. Pass if cert valid and not expiring within 30 days, warn if expiring within 30 days, fail if expired or no cert. Use `date` parsing — be aware that macOS `date -j` differs from GNU `date -d` for date arithmetic. Simplest approach: extract the expiry date string and report it, doing a simple string comparison or using `openssl` if available. If cert parsing is too fragile, fall back to: pass if HTTPS curl succeeds (implies valid cert), fail if it errors.

10. **Section 7 — Connection Timing:** Use `report_section "Connection Timing"`. Use `curl -w` format string to extract timing breakdown: DNS lookup, TCP connect, TLS handshake, total time. Pattern from research: `curl -o /dev/null -s -w "DNS: %{time_namelookup}s\nConnect: %{time_connect}s\nTLS: %{time_appconnect}s\nTotal: %{time_total}s\n" "https://${HOST}"`. Report pass with the timing data. Warn if total time > 5s.

11. **Section 8 — Summary:** Same pattern as dns.sh — aggregate counts, report overall status.

Key implementation details:
- Strip protocol from TARGET once at the top, store in `HOST` variable.
- Use `$HOST` for dig, ping, nc commands (no protocol prefix).
- Use `http://$HOST` or `https://$HOST` for curl commands.
- Do NOT use `grep -P`. Use `grep -E` or `awk`.
- Do NOT use `sed -r`. Use `sed -E`.
- All external command calls should redirect stderr where appropriate: `2>/dev/null`.
- Script must be fully non-interactive.
  </action>
  <verify>
Run `bash scripts/diagnostics/connectivity.sh` (default target example.com) and confirm:
- Header shows target and date
- 7 sections appear with === markers (Local Network, DNS Resolution, ICMP, TCP Port, HTTP/HTTPS, TLS Certificate, Connection Timing)
- Individual checks show [PASS], [FAIL], or [WARN]
- Summary shows pass/fail/warn counts
- Script exits without prompting for input
- Run `bash scripts/diagnostics/connectivity.sh --help` shows usage
- Run `bash scripts/diagnostics/connectivity.sh https://google.com` works with protocol prefix (stripped internally)
- Verify cross-platform: confirm ping_host uses `-t` on macOS (Darwin) and `-w` on Linux, and get_local_ip tries `ip` before falling back to `ifconfig`
  </verify>
  <done>
connectivity.sh produces a structured report with 7 sections walking DNS-to-TLS layers, each check has [PASS]/[FAIL]/[WARN], cross-platform ping and ip/ifconfig work correctly, script runs non-interactively, and follows the same Pattern B structure as dns.sh.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add diagnose-connectivity Makefile target and update USECASES.md</name>
  <files>Makefile, USECASES.md</files>
  <action>
**Makefile changes:**

Add `diagnose-connectivity` to the `.PHONY` line.

Add the target in the "Diagnostic targets" section created in Plan 01 (right after `diagnose-dns`):

```makefile
diagnose-connectivity: ## Run connectivity diagnostic (usage: make diagnose-connectivity TARGET=<domain>)
	@bash scripts/diagnostics/connectivity.sh $(or $(TARGET),example.com)
```

**USECASES.md changes:**

Add a new "## Network Diagnostics" section. Place it AFTER the existing "## Network & Traffic Analysis" section and BEFORE "## File Carving & Forensics". Content:

```markdown
## Network Diagnostics

| I want to... | Command | Tool |
| -------------- | --------- | ------ |
| Diagnose DNS resolution issues | `make diagnose-dns TARGET=<domain>` | dig |
| Check full connectivity (DNS to TLS) | `make diagnose-connectivity TARGET=<domain>` | dig, ping, nc, curl |
```

Also add the diagnostic scripts to the "Typical Engagement Flow" section at the bottom — insert a step between discovery and port scan:

```
1.5  Diagnostics  make diagnose-dns TARGET=<domain>
                  make diagnose-connectivity TARGET=<domain>
```

Or if the numbering/flow doesn't fit naturally, add it as a standalone note after the flow.
  </action>
  <verify>
Run `make diagnose-connectivity` and confirm it produces the connectivity diagnostic report. Run `make help` and confirm both `diagnose-dns` and `diagnose-connectivity` appear. Check USECASES.md contains the "Network Diagnostics" section with both entries.
  </verify>
  <done>
`make diagnose-connectivity` works with default and custom TARGET. `make help` lists both diagnostic targets. USECASES.md has a "Network Diagnostics" section with entries for DNS and connectivity diagnostics.
  </done>
</task>

</tasks>

<verification>
1. `bash scripts/diagnostics/connectivity.sh` completes without errors and produces structured output
2. `bash scripts/diagnostics/connectivity.sh --help` shows usage information
3. `bash scripts/diagnostics/connectivity.sh google.com` works with custom target
4. `bash scripts/diagnostics/connectivity.sh https://google.com` works with protocol prefix
5. `make diagnose-connectivity` works via Makefile
6. `make help` shows both `diagnose-dns` and `diagnose-connectivity`
7. Output contains [PASS], [FAIL], or [WARN] indicators
8. Output contains section headers (===) for all 7 sections plus summary
9. Script does not prompt for input (non-interactive)
10. USECASES.md contains "Network Diagnostics" section with both diagnostic entries
</verification>

<success_criteria>
- Connectivity diagnostic script exists at scripts/diagnostics/connectivity.sh and is executable
- Running it produces a 7-section structured report walking DNS-to-TLS with pass/fail/warn indicators
- Cross-platform: ping uses correct flags per OS, ip/ifconfig fallback works
- Makefile target `diagnose-connectivity` works with default and custom TARGET
- USECASES.md updated with diagnostic "I want to..." entries
- Both diagnostic scripts follow identical Pattern B structure
</success_criteria>

<output>
After completion, create `.planning/phases/03-diagnostic-scripts/03-02-SUMMARY.md`
</output>
