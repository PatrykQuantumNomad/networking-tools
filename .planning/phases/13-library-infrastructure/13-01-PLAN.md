---
phase: 13-library-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/common.sh
  - scripts/lib/strict.sh
  - scripts/lib/colors.sh
  - scripts/lib/logging.sh
  - scripts/lib/validation.sh
  - scripts/lib/cleanup.sh
  - scripts/lib/output.sh
  - scripts/lib/diagnostic.sh
  - scripts/lib/nc_detect.sh
autonomous: true

must_haves:
  truths:
    - "All scripts load via their existing `source common.sh` line unchanged"
    - "Sourcing common.sh activates `set -eEuo pipefail` strict mode"
    - "An unhandled error prints a stack trace (file, line, function) to stderr"
    - "VERBOSE=1 enables debug output and timestamps on info/warn/success"
    - "NO_COLOR=1 or piping through cat produces zero ANSI escape codes"
    - "LOG_LEVEL=warn suppresses info messages but shows warn and error"
    - "make_temp() creates temp files cleaned up automatically on EXIT"
    - "retry_with_backoff() retries a command with exponential delay"
    - "Source guards prevent double-sourcing of any module"
  artifacts:
    - path: "scripts/lib/strict.sh"
      provides: "set -eEuo pipefail, inherit_errexit, ERR trap stack trace"
      contains: "_STRICT_LOADED"
    - path: "scripts/lib/colors.sh"
      provides: "Color variable definitions, NO_COLOR/terminal detection"
      contains: "_COLORS_LOADED"
    - path: "scripts/lib/logging.sh"
      provides: "info/success/warn/error/debug with LOG_LEVEL filtering and VERBOSE timestamps"
      contains: "_LOGGING_LOADED"
    - path: "scripts/lib/validation.sh"
      provides: "require_root, check_cmd, require_cmd, require_target"
      contains: "_VALIDATION_LOADED"
    - path: "scripts/lib/cleanup.sh"
      provides: "EXIT trap, make_temp(), register_cleanup(), retry_with_backoff()"
      contains: "_CLEANUP_LOADED"
    - path: "scripts/lib/output.sh"
      provides: "safety_banner(), is_interactive(), PROJECT_ROOT"
      contains: "_OUTPUT_LOADED"
    - path: "scripts/lib/diagnostic.sh"
      provides: "report_pass/fail/warn/skip/section, run_check, _run_with_timeout"
      contains: "_DIAGNOSTIC_LOADED"
    - path: "scripts/lib/nc_detect.sh"
      provides: "detect_nc_variant()"
      contains: "_NC_DETECT_LOADED"
    - path: "scripts/common.sh"
      provides: "Backward-compatible entry point sourcing all lib modules"
      contains: "_COMMON_LOADED"
  key_links:
    - from: "scripts/common.sh"
      to: "scripts/lib/*.sh"
      via: "source statements in dependency order"
      pattern: "source.*_LIB_DIR"
    - from: "scripts/lib/logging.sh"
      to: "scripts/lib/colors.sh"
      via: "uses color variables (RED, GREEN, YELLOW, BLUE, CYAN, NC)"
      pattern: "\\$\\{BLUE\\}|\\$\\{RED\\}|\\$\\{GREEN\\}"
    - from: "scripts/lib/validation.sh"
      to: "scripts/lib/logging.sh"
      via: "uses error() and info() functions"
      pattern: "error |info "
    - from: "scripts/lib/cleanup.sh"
      to: "scripts/lib/logging.sh"
      via: "uses debug() and warn() for retry messages"
      pattern: "debug |warn "
---

<objective>
Create the modular library infrastructure by splitting common.sh into 8 focused modules under scripts/lib/ and rewriting common.sh as a backward-compatible entry point that sources them in dependency order.

Purpose: This is the structural foundation for all subsequent v1.2 phases. Every enhancement (argument parsing, dual-mode, ShellCheck) depends on this modular library existing.

Output: 8 new files in scripts/lib/ plus a rewritten scripts/common.sh entry point. All consumer scripts continue to work with their existing source line.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-library-infrastructure/13-RESEARCH.md
@scripts/common.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core library modules (strict, colors, logging, validation)</name>
  <files>
    scripts/lib/strict.sh
    scripts/lib/colors.sh
    scripts/lib/logging.sh
    scripts/lib/validation.sh
  </files>
  <action>
Create `scripts/lib/` directory. Build the first 4 modules that form the core dependency chain:

**scripts/lib/strict.sh** (STRICT-01, STRICT-02, STRICT-03, STRICT-05):
- Source guard: `[[ -n "${_STRICT_LOADED:-}" ]] && return 0` + `_STRICT_LOADED=1`
- `set -eEuo pipefail` (upgrade from current `set -euo pipefail` — the `-E` flag enables ERR trap inheritance into functions)
- Version-gated `shopt -s inherit_errexit` for Bash 4.4+ (check `BASH_VERSINFO[0] >= 5 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 4)`)
- ERR trap handler `_strict_error_handler()` that prints stack trace to stderr using plain `echo` (NOT library functions — the error may have originated from a library function). Format:
  ```
  [ERROR] Command failed (exit $exit_code) at line $line_no: $command
    at function_name() in file.sh:line
    at main() in script.sh:line
  ```
  Start loop at `i=1` to skip the trap handler itself. Use `BASH_LINENO[$((i-1))]` for correct line mapping.
- Register trap: `trap '_strict_error_handler' ERR`

**scripts/lib/colors.sh** (LOG-03, STRICT-05):
- Source guard with `_COLORS_LOADED`
- Define color variables: RED, GREEN, YELLOW, BLUE, CYAN, NC — same values as current common.sh
- Disable all colors (set to empty string) when `NO_COLOR` env var is set OR stdout is not a terminal (`[[ ! -t 1 ]]`). Check `NO_COLOR` first. This matches success criterion #4 (zero ANSI codes when piped).

**scripts/lib/logging.sh** (LOG-01, LOG-02, LOG-04, LOG-05, STRICT-05):
- Source guard with `_LOGGING_LOADED`
- Set defaults: `LOG_LEVEL="${LOG_LEVEL:-info}"` and `VERBOSE="${VERBOSE:-0}"`
- When `VERBOSE >= 1`, override `LOG_LEVEL="debug"`
- Internal `_log_level_num()` function mapping debug=0, info=1, warn=2, error=3
- Internal `_should_log()` function comparing message level against current LOG_LEVEL
- `debug()`: gated by `_should_log debug`, always includes timestamp via `date '+%H:%M:%S'`, uses CYAN
- `info()`: gated by `_should_log info`, adds timestamp only when `VERBOSE >= 1`, uses BLUE — outputs to stdout (preserve current behavior)
- `success()`: gated by `_should_log info`, adds timestamp only when `VERBOSE >= 1`, uses GREEN — outputs to stdout
- `warn()`: gated by `_should_log warn`, adds timestamp only when `VERBOSE >= 1`, uses YELLOW — outputs to stdout
- `error()`: NOT gated by `_should_log` (errors always visible), adds timestamp only when `VERBOSE >= 1`, uses RED — outputs to stderr with `>&2` (preserve current behavior)
- CRITICAL: Default behavior (LOG_LEVEL=info, VERBOSE=0) MUST produce identical output to the current functions. The only additions are the `_should_log` guard (which passes at default level) and the conditional timestamp (which is empty at default VERBOSE).

**scripts/lib/validation.sh** (STRICT-05):
- Source guard with `_VALIDATION_LOADED`
- Move these functions verbatim from current common.sh: `require_root()`, `check_cmd()`, `require_cmd()`, `require_target()`
- No changes to function signatures or behavior
  </action>
  <verify>
Run: `bash -c 'source scripts/lib/strict.sh && echo "strict OK"'` — should print "strict OK"
Run: `bash -c 'source scripts/lib/colors.sh && echo "${BLUE}test${NC}"'` — should show colored output
Run: `bash -c 'source scripts/lib/colors.sh && source scripts/lib/logging.sh && info "test"'` — should print "[INFO] test"
Run: `bash -c 'source scripts/lib/colors.sh && source scripts/lib/logging.sh && source scripts/lib/validation.sh && require_cmd bash && echo "validation OK"'` — should print "validation OK"
  </verify>
  <done>
4 library modules exist in scripts/lib/ with source guards, strict mode active, ERR trap registered, color detection working, logging functions enhanced with level filtering, and validation functions moved unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create infrastructure modules and rewrite common.sh entry point</name>
  <files>
    scripts/lib/cleanup.sh
    scripts/lib/output.sh
    scripts/lib/diagnostic.sh
    scripts/lib/nc_detect.sh
    scripts/common.sh
  </files>
  <action>
Build the remaining 4 library modules and rewrite common.sh as the entry point:

**scripts/lib/cleanup.sh** (STRICT-04, INFRA-03, INFRA-04, STRICT-05):
- Source guard with `_CLEANUP_LOADED`
- Declare tracking arrays: `_CLEANUP_FILES=()` and `_CLEANUP_DIRS=()`
- `_cleanup_handler()` function: captures `$?` first, iterates `_CLEANUP_FILES` removing each with `rm -f "$f" 2>/dev/null || true`, iterates `_CLEANUP_DIRS` removing each with `rm -rf "$d" 2>/dev/null || true`, then `exit "$exit_code"` to preserve original exit status
- Register: `trap '_cleanup_handler' EXIT` — only EXIT, NOT INT/TERM (EXIT trap fires on those signals too; trapping both causes double execution per Greg's Wiki SignalTrap)
- `register_cleanup()` function: takes a command string, appends to an `_CLEANUP_COMMANDS` array, executes each in `_cleanup_handler` via `eval "$cmd" 2>/dev/null || true`
- Update `_cleanup_handler` to also run registered commands
- `make_temp()` function: takes optional type ("file" or "dir", default "file") and optional prefix (default "ntool"). Uses `mktemp` with `${TMPDIR:-/tmp}/${prefix}.XXXXXX`. Appends result to appropriate tracking array. Echoes the path.
- `retry_with_backoff()` function: takes max_attempts (default 3), delay (default 1), then the command. Runs command in a loop, on failure: if attempts exhausted, `warn` and return 1. Otherwise `debug` the retry message, `sleep "$delay"`, double delay, increment attempt. Uses `debug()` and `warn()` from logging.sh.

**scripts/lib/output.sh** (STRICT-05):
- Source guard with `_OUTPUT_LOADED`
- Move these verbatim from current common.sh: `safety_banner()`, `is_interactive()`
- Move `PROJECT_ROOT` calculation verbatim. IMPORTANT: `PROJECT_ROOT` must resolve relative to the SOURCING script's location, not lib/output.sh. Use the same formula as current common.sh: `PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"`. Since output.sh is in `scripts/lib/`, the `..` goes to `scripts/`, so we need `../..` to reach the project root. Change to: `PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"`

**scripts/lib/diagnostic.sh** (STRICT-05):
- Source guard with `_DIAGNOSTIC_LOADED`
- Move these verbatim from current common.sh: `report_pass()`, `report_fail()`, `report_warn()`, `report_skip()`, `report_section()`, `_run_with_timeout()`, `run_check()`
- No changes to function signatures or behavior

**scripts/lib/nc_detect.sh** (STRICT-05):
- Source guard with `_NC_DETECT_LOADED`
- Move `detect_nc_variant()` verbatim from current common.sh
- No changes to function signature or behavior

**scripts/common.sh** (INFRA-01, INFRA-02):
- Keep the bash version guard at the top (lines 5-12 of current file) unchanged
- Add source guard: `[[ -n "${_COMMON_LOADED:-}" ]] && return 0` + `_COMMON_LOADED=1`
- Remove `set -euo pipefail` (now in strict.sh as `set -eEuo pipefail`)
- Remove all color variable definitions (now in colors.sh)
- Remove all function definitions (now in lib modules)
- Remove PROJECT_ROOT calculation (now in output.sh)
- Add: `_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/lib" && pwd)"`
- Add source statements in dependency order:
  1. `source "${_LIB_DIR}/strict.sh"`
  2. `source "${_LIB_DIR}/colors.sh"`
  3. `source "${_LIB_DIR}/logging.sh"`
  4. `source "${_LIB_DIR}/validation.sh"`
  5. `source "${_LIB_DIR}/cleanup.sh"`
  6. `source "${_LIB_DIR}/output.sh"`
  7. `source "${_LIB_DIR}/diagnostic.sh"`
  8. `source "${_LIB_DIR}/nc_detect.sh"`
- Keep the file header comment: `# common.sh — Shared utility functions for all tool scripts`
  </action>
  <verify>
Run: `bash -c 'source scripts/common.sh && echo "common.sh loaded OK"'` from the project root — should succeed
Run: `bash -c 'source scripts/common.sh && declare -F | wc -l'` — should show all expected functions defined
Run: `bash scripts/nmap/examples.sh scanme.nmap.org < /dev/null 2>/dev/null | head -5` — should produce output (not crash)
Run: `bash scripts/check-tools.sh 2>/dev/null | head -3` — should produce output (not crash)

Cross-module dependency verification (key_links):
Run: `bash -c 'source scripts/common.sh && info "color test"'` — should produce "[INFO] color test" with BLUE coloring (logging.sh -> colors.sh)
Run: `bash -c 'source scripts/common.sh && require_cmd bash'` — should succeed silently; confirms validation.sh can call info/error from logging.sh
Run: `bash -c 'source scripts/common.sh && require_cmd nonexistent_cmd_xyz 2>&1 || true'` — should print an error message via error() from logging.sh (validation.sh -> logging.sh)
Run: `bash -c 'source scripts/common.sh && retry_with_backoff 1 0.1 false 2>&1; true'` — should print retry/warning messages via debug()/warn() from logging.sh (cleanup.sh -> logging.sh)
  </verify>
  <done>
All 8 library modules exist in scripts/lib/. The rewritten common.sh sources them in dependency order. Consumer scripts load successfully via their existing source line.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify:
1. `bash -c 'source scripts/common.sh && echo OK'` succeeds
2. `bash scripts/nmap/examples.sh scanme.nmap.org < /dev/null 2>/dev/null | head -3` produces output identical to before
3. `bash scripts/check-tools.sh 2>/dev/null | head -3` works
4. `ls scripts/lib/*.sh | wc -l` returns 8
5. Each lib file starts with a source guard pattern
</verification>

<success_criteria>
- 8 module files exist in scripts/lib/ with correct source guards
- scripts/common.sh is a thin entry point sourcing all 8 modules
- All functions from current common.sh are available after sourcing
- No consumer script source lines need changing
</success_criteria>

<output>
After completion, create `.planning/phases/13-library-infrastructure/13-01-SUMMARY.md`
</output>
