---
phase: 19-library-unit-tests
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/lib-output.bats
  - tests/lib-retry.bats
autonomous: true

must_haves:
  truths:
    - "run_or_show prints command in show mode without executing it"
    - "run_or_show executes command in execute mode"
    - "safety_banner outputs authorization warning text"
    - "is_interactive returns 1 (false) when stdin is not a terminal"
    - "retry_with_backoff returns 0 on immediate success"
    - "retry_with_backoff returns 1 after max attempts exhausted with failing command"
    - "retry_with_backoff succeeds on nth attempt when command starts succeeding"
  artifacts:
    - path: "tests/lib-output.bats"
      provides: "UNIT-05 run_or_show, safety_banner, is_interactive tests"
      contains: "@test"
    - path: "tests/lib-retry.bats"
      provides: "UNIT-06 retry_with_backoff tests"
      contains: "@test"
  key_links:
    - from: "tests/lib-output.bats"
      to: "scripts/lib/output.sh"
      via: "source common.sh in setup()"
      pattern: "source.*common\\.sh"
    - from: "tests/lib-retry.bats"
      to: "scripts/lib/cleanup.sh"
      via: "source common.sh in setup()"
      pattern: "source.*common\\.sh"
---

<objective>
Create BATS unit tests for output functions (output.sh) and retry logic (cleanup.sh retry_with_backoff).

Purpose: Prove run_or_show correctly shows vs executes commands, safety_banner prints warning, is_interactive detects non-terminal (UNIT-05), and retry_with_backoff handles retry count, delay, and success/failure paths (UNIT-06).
Output: tests/lib-output.bats (~7 tests) and tests/lib-retry.bats (~5 tests)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-library-unit-tests/19-RESEARCH.md
@.planning/phases/18-bats-infrastructure/18-01-SUMMARY.md
@tests/smoke.bats
@tests/test_helper/common-setup.bash
@scripts/lib/output.sh
@scripts/lib/cleanup.sh
@scripts/common.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib-output.bats with run_or_show, safety_banner, is_interactive tests (UNIT-05)</name>
  <files>tests/lib-output.bats</files>
  <action>
Create `tests/lib-output.bats` following the established pattern.

setup() must:
1. `load 'test_helper/common-setup'` and call `_common_setup`
2. Define `show_help() { echo "test help"; }`
3. `source "${PROJECT_ROOT}/scripts/common.sh"`
4. `set +eEuo pipefail` and `trap - ERR`
5. Reset: `EXECUTE_MODE="show"`, `VERBOSE=0`, `LOG_LEVEL="info"`

IMPORTANT context on how output.sh functions work:
- `run_or_show "description" command [args...]`:
  - In show mode (default): calls `info "$description"` (stdout), then prints `   $*` (indented command) to stdout
  - In execute mode: calls `info "$description"` (stdout), calls `debug "Executing: $*"` (stdout if LOG_LEVEL=debug), then RUNS `"$@"` (actually executes the command)
- `safety_banner()`: prints multi-line warning with "AUTHORIZED USE ONLY" text via `echo -e` to stdout. Uses `$RED` and `$NC` color variables (empty under NO_COLOR=1).
- `is_interactive()`: returns 0 if `[[ -t 0 ]]` (stdin is terminal), 1 otherwise. In BATS, stdin is never a terminal, so this always returns 1.
- `confirm_execute()`: prompts user interactively. Testing would require terminal stdin. Skip deep testing -- just test that it's a no-op in show mode.

Write these tests (~7 total):

**run_or_show tests:**
1. `run_or_show prints command in show mode`: set EXECUTE_MODE="show" (already default), `run run_or_show "1) List files" ls -la`, assert_success, assert_output --partial "[INFO]", assert_output --partial "1) List files", assert_output --partial "ls -la"
2. `run_or_show does not execute command in show mode`: create a marker approach -- use `run run_or_show "1) Touch file" touch "${BATS_TEST_TMPDIR}/should-not-exist"`, assert_success, then `assert_file_not_exists "${BATS_TEST_TMPDIR}/should-not-exist"`
3. `run_or_show executes command in execute mode`: set `EXECUTE_MODE="execute"`, `run run_or_show "1) Create marker" touch "${BATS_TEST_TMPDIR}/marker"`, assert_success. Then outside `run`, `assert_file_exists "${BATS_TEST_TMPDIR}/marker"`. NOTE: `run` creates a subshell, so `touch` inside `run` writes to the real filesystem. `$BATS_TEST_TMPDIR` is a real path accessible from subshells.
4. `run_or_show shows indented command in show mode`: `run run_or_show "1) Example" echo hello`, assert_output --partial "   echo hello" (3 spaces indent)

**safety_banner tests:**
5. `safety_banner outputs authorization warning`: `run safety_banner`, assert_success, assert_output --partial "AUTHORIZED USE ONLY", assert_output --partial "written permission"
6. `safety_banner contains no ANSI codes under NO_COLOR`: `run safety_banner`, refute_output --regexp $'\033' (or use `[[ "$output" != *$'\033'* ]]`)

**is_interactive tests:**
7. `is_interactive returns false in BATS (non-terminal stdin)`: `run is_interactive`, assert_failure (returns 1 because stdin is not a terminal in BATS)

Do NOT test `confirm_execute` deeply -- it requires interactive terminal stdin and uses `read`. Just note in a comment that it is tested via script integration tests in Phase 20.

Do NOT modify smoke.bats or common-setup.bash.
  </action>
  <verify>Run `./tests/bats/bin/bats tests/lib-output.bats` -- all tests pass.</verify>
  <done>7 tests in lib-output.bats pass, covering run_or_show show/execute modes, safety_banner output, and is_interactive non-terminal behavior.</done>
</task>

<task type="auto">
  <name>Task 2: Create lib-retry.bats with retry_with_backoff tests (UNIT-06)</name>
  <files>tests/lib-retry.bats</files>
  <action>
Create `tests/lib-retry.bats` following the established pattern.

setup() must:
1. `load 'test_helper/common-setup'` and call `_common_setup`
2. Define `show_help() { echo "test help"; }`
3. `source "${PROJECT_ROOT}/scripts/common.sh"`
4. `set +eEuo pipefail` and `trap - ERR`
5. CRITICAL: Override sleep to be instant: `sleep() { :; }` then `export -f sleep` -- this prevents real delays in tests. The `export -f` is essential because `run` executes in a subshell that needs the override.
6. Reset: `VERBOSE=0`, `LOG_LEVEL="info"`

IMPORTANT context on how retry_with_backoff works:
- Signature: `retry_with_backoff max_attempts initial_delay command [args...]`
- Runs `"$@"` (the command). If it succeeds (returns 0), immediately returns 0.
- If command fails and attempt < max_attempts: calls `debug` (log), `sleep "$delay"`, doubles delay via `bc`, increments attempt counter, retries.
- If command fails and attempt >= max_attempts: calls `warn` (log), returns 1.
- Uses `bc` for delay doubling (`echo "$delay * 2" | bc`). `bc` is available on macOS at /usr/bin/bc.

Write these tests (~5 total):

1. `retry_with_backoff returns 0 on immediate success`: `run retry_with_backoff 3 1 true`, assert_success
2. `retry_with_backoff returns 1 after max attempts with failing command`: `run retry_with_backoff 3 1 false`, assert_failure
3. `retry_with_backoff succeeds on second attempt`: Create a counter-based command that fails once then succeeds:
    ```bash
    local counter_file="${BATS_TEST_TMPDIR}/counter"
    echo "0" > "$counter_file"

    attempt_cmd() {
        local count
        count=$(<"$counter_file")
        count=$((count + 1))
        echo "$count" > "$counter_file"
        (( count >= 2 ))
    }
    export -f attempt_cmd

    run retry_with_backoff 3 1 attempt_cmd
    assert_success
    ```
4. `retry_with_backoff retries exactly max_attempts times`: Create a counter that counts invocations:
    ```bash
    local counter_file="${BATS_TEST_TMPDIR}/counter"
    echo "0" > "$counter_file"

    counting_fail() {
        local count
        count=$(<"$counter_file")
        count=$((count + 1))
        echo "$count" > "$counter_file"
        return 1
    }
    export -f counting_fail

    run retry_with_backoff 3 1 counting_fail
    assert_failure
    # Verify exactly 3 attempts were made
    assert_equal "$(cat "${BATS_TEST_TMPDIR}/counter")" "3"
    ```
    NOTE: Since `run` executes in a subshell, the counter_file is written by the subshell. After `run` completes, read the counter_file from the parent to verify attempt count.

5. `retry_with_backoff with 1 max attempt tries once`:
    ```bash
    local counter_file="${BATS_TEST_TMPDIR}/counter"
    echo "0" > "$counter_file"

    counting_fail() {
        local count
        count=$(<"$counter_file")
        count=$((count + 1))
        echo "$count" > "$counter_file"
        return 1
    }
    export -f counting_fail

    run retry_with_backoff 1 1 counting_fail
    assert_failure
    assert_equal "$(cat "${BATS_TEST_TMPDIR}/counter")" "1"
    ```

IMPORTANT: The `export -f` for `attempt_cmd` and `counting_fail` is essential because `run` creates a subshell. Without `export -f`, the function is not visible inside `run`. Also `export -f sleep` in setup() ensures the mock sleep is used inside `run`.

Do NOT modify smoke.bats or common-setup.bash.
  </action>
  <verify>Run `./tests/bats/bin/bats tests/lib-retry.bats` -- all tests pass with no real delays (instant execution, not 3+ seconds). Then `make test` confirms all tests pass together.</verify>
  <done>5 tests in lib-retry.bats pass, covering immediate success, max attempts exhausted, mid-retry success, exact retry count, and single-attempt failure.</done>
</task>

</tasks>

<verification>
Run `make test` from project root. All tests pass:
- 5 existing smoke tests
- 7 lib-output tests (UNIT-05)
- 5 lib-retry tests (UNIT-06)
Plus any other lib-* tests from parallel plans.
</verification>

<success_criteria>
- lib-output.bats exists with ~7 tests covering run_or_show show/execute modes, safety_banner, and is_interactive
- lib-retry.bats exists with ~5 tests covering retry success/failure/partial-success paths and attempt counting
- `make test` exits 0 with all tests passing and no real sleep delays
- No modifications to smoke.bats or common-setup.bash
</success_criteria>

<output>
After completion, create `.planning/phases/19-library-unit-tests/19-03-SUMMARY.md`
</output>
