---
phase: 24-library-unit-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/lib-args.bats
  - tests/lib-output.bats
autonomous: true

must_haves:
  truths:
    - "-j flag sets JSON_MODE=1 and preserves remaining args"
    - "--json long flag works identically to -j"
    - "-j combined with -x sets both JSON_MODE=1 and EXECUTE_MODE=execute"
    - "-j combined with -v sets both JSON_MODE=1 and increments VERBOSE"
    - "-j resets all color variables to empty strings"
    - "-j fails gracefully when jq is unavailable"
    - "-- stops flag parsing so -j after -- is treated as positional arg"
    - "safety_banner produces no output when JSON_MODE=1"
    - "confirm_execute returns 0 immediately when JSON_MODE=1"
  artifacts:
    - path: "tests/lib-args.bats"
      provides: "BATS tests for -j/--json flag parsing"
      contains: "-j sets JSON_MODE"
    - path: "tests/lib-output.bats"
      provides: "BATS tests for JSON-mode output suppression"
      contains: "safety_banner.*JSON"
  key_links:
    - from: "tests/lib-args.bats"
      to: "scripts/lib/args.sh"
      via: "parse_common_args function"
      pattern: "parse_common_args.*-j"
    - from: "tests/lib-output.bats"
      to: "scripts/lib/output.sh"
      via: "safety_banner and confirm_execute functions"
      pattern: "JSON_MODE=1"
---

<objective>
Add -j/--json flag tests to tests/lib-args.bats and JSON-mode suppression tests to tests/lib-output.bats.

Purpose: Prove parse_common_args correctly handles -j in all flag combinations, and output.sh functions respect JSON mode.
Output: 8 new tests in lib-args.bats + 2 new tests in lib-output.bats.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-library-unit-tests/24-RESEARCH.md
@.planning/phases/23-json-library-flag-integration/23-01-SUMMARY.md

@scripts/lib/args.sh
@scripts/lib/output.sh
@scripts/lib/json.sh
@tests/lib-args.bats
@tests/lib-output.bats
@tests/lib-cleanup.bats
@tests/test_helper/common-setup.bash
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add -j/--json flag tests to lib-args.bats</name>
  <files>tests/lib-args.bats</files>
  <action>
Append new -j/--json tests to the END of the existing tests/lib-args.bats file (after the 12 existing tests). Add a section comment header to separate old from new.

All -j tests MUST use subprocess pattern (`run bash -c '...'`) because parse_common_args -j runs `exec 3>&1; exec 1>&2` which would corrupt BATS process I/O. This is the critical lesson from 24-RESEARCH.md.

**Subprocess helper** -- define _run_parse_json at top of the new section:
```bash
# --- JSON flag tests (Phase 24, TEST-02) ---
# All -j tests use subprocess isolation because parse_common_args -j
# runs exec 3>&1 and exec 1>&2, which would corrupt BATS I/O.

_run_parse_json() {
    local args="$1"
    local echo_vars="${2:-JSON_MODE=\$JSON_MODE}"
    run bash -c '
        exec 3>&-
        export NO_COLOR=1
        show_help() { echo "test help output"; }
        source "'"${PROJECT_ROOT}"'/scripts/common.sh"
        set +eEuo pipefail
        trap - ERR
        VERBOSE=0; LOG_LEVEL="info"; EXECUTE_MODE="show"; JSON_MODE=0; REMAINING_ARGS=()
        RED="x"; GREEN="x"; YELLOW="x"; BLUE="x"; CYAN="x"; NC="x"
        parse_common_args '"$args"'
        '"$echo_vars"'
    '
}
```

**Tests to add (8 tests):**

1. `-j sets JSON_MODE=1` — _run_parse_json "-j target" 'echo "JSON_MODE=$JSON_MODE"; echo "REMAINING=${REMAINING_ARGS[*]}"'; assert_success; assert_output --partial "JSON_MODE=1"; assert_output --partial "REMAINING=target"

2. `--json long flag works same as -j` — _run_parse_json "--json target" 'echo "JSON_MODE=$JSON_MODE"'; assert_success; assert_output --partial "JSON_MODE=1"

3. `-j resets all color variables to empty` — _run_parse_json "-j target" 'echo "RED=${RED}END"; echo "GREEN=${GREEN}END"; echo "YELLOW=${YELLOW}END"; echo "BLUE=${BLUE}END"; echo "CYAN=${CYAN}END"; echo "NC=${NC}END"'; assert_success; assert_output --partial "RED=END"; assert_output --partial "GREEN=END"; assert_output --partial "YELLOW=END"; assert_output --partial "BLUE=END"; assert_output --partial "CYAN=END"; assert_output --partial "NC=END"

4. `-j -x sets both JSON_MODE and EXECUTE_MODE` — _run_parse_json "-j -x target" 'echo "JSON_MODE=$JSON_MODE"; echo "EXECUTE_MODE=$EXECUTE_MODE"'; assert_success; assert_output --partial "JSON_MODE=1"; assert_output --partial "EXECUTE_MODE=execute"

5. `-j -v sets both JSON_MODE and VERBOSE` — _run_parse_json "-j -v target" 'echo "JSON_MODE=$JSON_MODE"; echo "VERBOSE=$VERBOSE"'; assert_success; assert_output --partial "JSON_MODE=1"; assert_output --partial "VERBOSE=1"

6. `-- -j treats -j as positional arg` — This test does NOT need subprocess since parse_common_args won't activate JSON mode. Use direct call: parse_common_args -- -j; assert_equal "$JSON_MODE" "0"; assert_equal "${REMAINING_ARGS[*]}" "-j"

7. `-j fails when jq unavailable` — run bash -c 'exec 3>&-; export NO_COLOR=1; show_help() { echo "test help output"; }; source "'"${PROJECT_ROOT}"'/scripts/common.sh"; set +eEuo pipefail; trap - ERR; VERBOSE=0; LOG_LEVEL="info"; EXECUTE_MODE="show"; JSON_MODE=0; REMAINING_ARGS=(); _JSON_JQ_AVAILABLE=0; parse_common_args -j target'; assert_failure; assert_output --partial "jq is required"

8. `-j -h shows help and exits 0` — run bash -c 'exec 3>&-; export NO_COLOR=1; show_help() { echo "test help output"; }; source "'"${PROJECT_ROOT}"'/scripts/common.sh"; set +eEuo pipefail; trap - ERR; VERBOSE=0; LOG_LEVEL="info"; EXECUTE_MODE="show"; JSON_MODE=0; REMAINING_ARGS=(); parse_common_args -j -h'; assert_success; assert_output "test help output"
    Note: -h is parsed before -j's activation block runs, so help takes precedence.
    Actually, looking at the code: the loop processes -j first (sets JSON_MODE=1), then -h (calls show_help, exits 0). The JSON activation block runs AFTER the loop. So -h still exits before activation. Test with subprocess since -j is present in args.

**Important:** For test 6 (-- -j), since JSON mode is NOT activated, no exec redirections happen, so direct call is safe. For test 7 (-j fails), override _JSON_JQ_AVAILABLE=0 AFTER sourcing common.sh but BEFORE parse_common_args (per research: don't manipulate PATH). For test 8 (-j -h), help exits 0 during the parsing loop before the JSON activation block runs.
  </action>
  <verify>
Run `bats tests/lib-args.bats` -- all 20 tests pass (12 existing + 8 new). Check that no existing tests regressed.
  </verify>
  <done>
tests/lib-args.bats contains 20 passing tests total. The 8 new tests cover: -j basic, --json long flag, color reset, -j -x combo, -j -v combo, -- -j positional, jq-unavailable failure, -j -h help precedence.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add JSON-mode suppression tests to lib-output.bats</name>
  <files>tests/lib-output.bats</files>
  <action>
Append new JSON-mode tests to the END of the existing tests/lib-output.bats file (after the 7 existing tests). Add a section comment header.

These are direct-call tests (no subprocess needed) because safety_banner and confirm_execute do NOT touch fd3 or run exec redirections -- they simply check json_is_active and return early.

**Tests to add (2 tests):**

1. `safety_banner suppressed in JSON mode` — JSON_MODE=1; run safety_banner; assert_success; assert_output ""

2. `confirm_execute skipped in JSON mode` — JSON_MODE=1; EXECUTE_MODE="execute"; run confirm_execute "target"; assert_success; assert_output ""

**Section header:**
```bash
# --- JSON mode suppression tests (Phase 24) ---
```

**Important:** The setup() already sources common.sh and resets EXECUTE_MODE="show". For test 2, set EXECUTE_MODE="execute" before calling confirm_execute to ensure we're testing the JSON skip path, not the show-mode early return.
  </action>
  <verify>
Run `bats tests/lib-output.bats` -- all 9 tests pass (7 existing + 2 new). Run `bats tests/` to confirm full suite passes.
  </verify>
  <done>
tests/lib-output.bats contains 9 passing tests. The 2 new tests confirm safety_banner produces no output and confirm_execute returns 0 silently when JSON_MODE=1. Full suite passes with 0 failures.
  </done>
</task>

</tasks>

<verification>
- `bats tests/lib-args.bats` passes with 20 tests (12 existing + 8 new)
- `bats tests/lib-output.bats` passes with 9 tests (7 existing + 2 new)
- `bats tests/` passes with 0 failures (266 existing + all new tests)
- No BATS fd3 TAP corruption in any test run
</verification>

<success_criteria>
- tests/lib-args.bats has 8 new -j/--json tests, all passing
- tests/lib-output.bats has 2 new JSON-mode suppression tests, all passing
- All flag combinations tested: -j, --json, -j -x, -j -v, -- -j, -j -h, -j with no jq
- Color reset verified: RED/GREEN/YELLOW/BLUE/CYAN/NC all empty after -j
- Full test suite green with 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/24-library-unit-tests/24-02-SUMMARY.md`
</output>
