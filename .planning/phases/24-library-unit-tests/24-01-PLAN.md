---
phase: 24-library-unit-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/lib-json.bats
autonomous: true

must_haves:
  truths:
    - "json_is_active returns true only when JSON_MODE=1"
    - "json_set_meta populates tool, target, script, and timestamp when active, and is a no-op when inactive"
    - "json_add_result accumulates execute-mode results with exit_code/stdout/stderr/command"
    - "json_add_example accumulates show-mode examples with description/command"
    - "json_finalize produces a valid JSON envelope with meta/results/summary keys"
    - "json_finalize with empty results produces an empty array"
    - "json_finalize in execute mode counts succeeded/failed correctly"
    - "_json_require_jq exits 1 when jq is unavailable"
    - "Special characters in descriptions and commands are properly JSON-escaped"
  artifacts:
    - path: "tests/lib-json.bats"
      provides: "BATS unit tests for all lib/json.sh functions"
      min_lines: 120
  key_links:
    - from: "tests/lib-json.bats"
      to: "scripts/lib/json.sh"
      via: "source common.sh loads json.sh"
      pattern: "source.*common\\.sh"
---

<objective>
Create tests/lib-json.bats with comprehensive BATS unit tests for all lib/json.sh functions.

Purpose: Prove json.sh functions are correct before any scripts are migrated to use JSON output (Phase 25 depends on this).
Output: tests/lib-json.bats with ~18-20 passing tests covering all public and internal json.sh functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-library-unit-tests/24-RESEARCH.md
@.planning/phases/23-json-library-flag-integration/23-01-SUMMARY.md

@scripts/lib/json.sh
@scripts/lib/args.sh
@scripts/common.sh
@tests/lib-args.bats
@tests/lib-cleanup.bats
@tests/test_helper/common-setup.bash
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tests/lib-json.bats with direct-call and subprocess tests</name>
  <files>tests/lib-json.bats</files>
  <action>
Create tests/lib-json.bats following the exact patterns from 24-RESEARCH.md.

**File header:**
```
#!/usr/bin/env bats
# tests/lib-json.bats — Unit tests for JSON output library (scripts/lib/json.sh)
# TEST-01: Proves all json.sh public functions and internal helpers work correctly.
```

**setup() function** — follow the verified pattern from research:
- load common-setup, call _common_setup
- Define show_help stub
- Source common.sh
- set +eEuo pipefail; trap - ERR
- Reset all JSON state: JSON_MODE=0, _JSON_TOOL="", _JSON_TARGET="", _JSON_SCRIPT="", _JSON_STARTED="", _JSON_RESULTS=(), EXECUTE_MODE="show", VERBOSE=0, LOG_LEVEL="info", REMAINING_ARGS=()

**Subprocess helper** — define _run_json_subprocess at top (after setup):
```bash
_run_json_subprocess() {
    local body="$1"
    run bash -c '
        exec 3>&-
        export NO_COLOR=1
        show_help() { echo "test help"; }
        source "'"${PROJECT_ROOT}"'/scripts/common.sh"
        set +eEuo pipefail
        trap - ERR
        JSON_MODE=1
        _JSON_TOOL=""
        _JSON_TARGET=""
        _JSON_SCRIPT=""
        _JSON_STARTED="2026-01-01T00:00:00Z"
        _JSON_RESULTS=()
        EXECUTE_MODE="show"
        '"$body"'
    '
}
```
This closes BATS fd3, forces json_finalize to use stdout fallback path. Uses the exact PROJECT_ROOT quoting pattern from lib-cleanup.bats.

**Direct-call tests (no subprocess needed):**

1. `json_is_active returns false when JSON_MODE=0` — JSON_MODE=0; run json_is_active; assert_failure
2. `json_is_active returns true when JSON_MODE=1` — JSON_MODE=1; run json_is_active; assert_success
3. `json_is_active returns false when JSON_MODE unset` — unset JSON_MODE; run json_is_active; assert_failure
4. `json_set_meta is no-op when inactive` — JSON_MODE=0; json_set_meta "nmap" "target"; assert_equal "$_JSON_TOOL" ""
5. `json_set_meta populates tool and target when active` — JSON_MODE=1; json_set_meta "nmap" "192.168.1.1"; assert_equal "$_JSON_TOOL" "nmap"; assert_equal "$_JSON_TARGET" "192.168.1.1"; [[ -n "$_JSON_STARTED" ]]
6. `json_set_meta handles empty target` — JSON_MODE=1; json_set_meta "nmap" ""; assert_equal "$_JSON_TOOL" "nmap"; assert_equal "$_JSON_TARGET" ""
7. `json_set_meta sets ISO 8601 timestamp` — JSON_MODE=1; json_set_meta "nmap" "target"; [[ "$_JSON_STARTED" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$ ]]
8. `json_add_result is no-op when inactive` — JSON_MODE=0; json_add_result "test" 0 "out" "err" "cmd"; assert_equal "${#_JSON_RESULTS[@]}" "0"
9. `json_add_example is no-op when inactive` — JSON_MODE=0; json_add_example "test" "cmd"; assert_equal "${#_JSON_RESULTS[@]}" "0"
10. `json_finalize is no-op when inactive` — JSON_MODE=0; run json_finalize; assert_success; assert_output ""
11. `_json_require_jq exits 1 when jq unavailable` — _JSON_JQ_AVAILABLE=0; run _json_require_jq; assert_failure; assert_output --partial "jq is required"
12. `_json_require_jq succeeds when jq available` — _JSON_JQ_AVAILABLE=1; run _json_require_jq; assert_success

**Subprocess tests (use _run_json_subprocess helper):**

13. `json_finalize produces valid JSON with empty results` — _run_json_subprocess '_JSON_TOOL="nmap"; _JSON_TARGET="target"; json_finalize'; assert_success; echo "$output" | jq -e '.results == []'; echo "$output" | jq -e '.summary.total == 0'
14. `json_finalize show mode envelope has correct structure` — _run_json_subprocess '_JSON_TOOL="nmap"; _JSON_TARGET="192.168.1.1"; json_add_example "Port scan" "nmap -p 80 target"; json_finalize'; assert_success; echo "$output" | jq -e '.meta.tool == "nmap"'; echo "$output" | jq -e '.meta.target == "192.168.1.1"'; echo "$output" | jq -e '.meta.mode == "show"'; echo "$output" | jq -e '.results | length == 1'; echo "$output" | jq -e '.results[0].command == "nmap -p 80 target"'; echo "$output" | jq -e '.summary.total == 1'; echo "$output" | jq -e '.summary.succeeded == 1'; echo "$output" | jq -e '.summary.failed == 0'
15. `json_finalize execute mode counts succeeded and failed` — _run_json_subprocess 'EXECUTE_MODE="execute"; _JSON_TOOL="nmap"; _JSON_TARGET="target"; json_add_result "Good" 0 "ok" "" "cmd1"; json_add_result "Bad" 1 "" "err" "cmd2"; json_finalize'; assert_success; echo "$output" | jq -e '.meta.mode == "execute"'; echo "$output" | jq -e '.summary.total == 2'; echo "$output" | jq -e '.summary.succeeded == 1'; echo "$output" | jq -e '.summary.failed == 1'
16. `json_add_example accumulates multiple examples` — _run_json_subprocess '_JSON_TOOL="nmap"; _JSON_TARGET="target"; json_add_example "First" "cmd1"; json_add_example "Second" "cmd2"; json_add_example "Third" "cmd3"; json_finalize'; assert_success; echo "$output" | jq -e '.results | length == 3'; echo "$output" | jq -e '.results[2].description == "Third"'
17. `json_add_result accumulates with all fields` — _run_json_subprocess 'EXECUTE_MODE="execute"; _JSON_TOOL="test"; _JSON_TARGET="target"; json_add_result "Scan" 0 "output here" "warnings" "nmap -sV target"; json_finalize'; assert_success; echo "$output" | jq -e '.results[0].description == "Scan"'; echo "$output" | jq -e '.results[0].exit_code == 0'; echo "$output" | jq -e '.results[0].stdout == "output here"'; echo "$output" | jq -e '.results[0].stderr == "warnings"'; echo "$output" | jq -e '.results[0].command == "nmap -sV target"'
18. `special characters are properly JSON-escaped` — _run_json_subprocess '_JSON_TOOL="test"; _JSON_TARGET="target"; json_add_example "Test with \"quotes\" and \\backslash" "echo \"hello world\""; json_finalize'; assert_success; echo "$output" | jq -e '.results | length == 1' (jq parsing validates escaping correctness)
19. `json_finalize includes started and finished timestamps` — _run_json_subprocess '_JSON_TOOL="test"; _JSON_TARGET="target"; json_finalize'; assert_success; echo "$output" | jq -e '.meta.started == "2026-01-01T00:00:00Z"'; echo "$output" | jq -e 'has("meta") and .meta | has("finished")'

**Important implementation notes:**
- The _run_json_subprocess helper body is injected via single-quote break pattern ('"$body"'). Each test passes a single-quoted string as the body.
- For test 18 (special characters): the double quotes and backslash in the subprocess body need careful escaping. Use the pattern from research: `json_add_example "Test with \"quotes\" and \\backslash" "echo \"hello world\""`.
- All jq -e assertions must follow `assert_success` since they depend on $output being set by `run`.
- Do NOT call json_add_result or json_add_example directly in BATS (they call jq which is fine, but json_finalize uses fd3 so must be in subprocess).
  </action>
  <verify>
Run `bats tests/lib-json.bats` -- all tests must pass (0 failures). Then run `bats tests/` to confirm no regressions in the full suite.
  </verify>
  <done>
tests/lib-json.bats exists with 18+ passing tests covering: json_is_active (3 cases), json_set_meta (4 cases), guard no-ops (3 cases), _json_require_jq (2 cases), json_finalize envelope (4 cases), accumulation (2 cases), special characters (1 case), timestamps (1 case). Full test suite passes with 0 failures.
  </done>
</task>

</tasks>

<verification>
- `bats tests/lib-json.bats` passes with 0 failures
- `bats tests/` passes with 0 failures (266 existing + new tests)
- No BATS fd3 TAP corruption (clean TAP output, no raw JSON in test runner output)
</verification>

<success_criteria>
- tests/lib-json.bats exists with 18+ tests
- All json.sh public functions tested (json_is_active, json_set_meta, json_add_result, json_add_example, json_finalize)
- Both internal helpers tested (_json_require_jq, _json_check_jq effect)
- Edge cases covered: inactive mode no-ops, empty results, empty target, special character escaping
- Full suite green
</success_criteria>

<output>
After completion, create `.planning/phases/24-library-unit-tests/24-01-SUMMARY.md`
</output>
