---
phase: 23-json-library-flag-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/json.sh
  - scripts/common.sh
  - scripts/lib/args.sh
  - scripts/lib/output.sh
autonomous: true

must_haves:
  truths:
    - "Passing -j to a use-case script that uses run_or_show activates JSON mode and outputs an envelope with meta, results, summary keys on fd3 (original stdout)"
    - "Passing -j without -x outputs example commands as JSON (show mode JSON)"
    - "Passing -j -x captures real tool output and structures it as JSON (execute mode JSON)"
    - "Scripts without -j work identically to before, even if jq is not installed"
    - "confirm_execute is suppressed in JSON mode"
    - "safety_banner is suppressed in JSON mode"
    - "Color codes are disabled in JSON mode (NO_COLOR=1 with color vars reset)"
    - "All JSON values are correctly escaped via jq --arg (RFC 8259)"
  artifacts:
    - path: "scripts/lib/json.sh"
      provides: "JSON state management, accumulation, and finalization"
      exports: ["json_is_active", "json_set_meta", "json_add_result", "json_add_example", "json_finalize"]
      contains: "_JSON_LOADED=1"
      min_lines: 90
    - path: "scripts/common.sh"
      provides: "Module load entry point with json.sh at position 6"
      contains: "source.*json.sh"
    - path: "scripts/lib/args.sh"
      provides: "Flag parsing with -j/--json support and JSON activation"
      contains: "-j|--json"
    - path: "scripts/lib/output.sh"
      provides: "run_or_show with 4 code paths, safety_banner skip, confirm_execute skip"
      contains: "json_is_active"
  key_links:
    - from: "scripts/lib/args.sh"
      to: "scripts/lib/json.sh"
      via: "_json_require_jq call in JSON activation block"
      pattern: "_json_require_jq"
    - from: "scripts/lib/output.sh"
      to: "scripts/lib/json.sh"
      via: "json_is_active, json_add_result, json_add_example calls in run_or_show"
      pattern: "json_add_result|json_add_example"
    - from: "scripts/lib/json.sh"
      to: "fd3"
      via: "json_finalize writes envelope to fd3 (or stdout fallback)"
      pattern: ">&3"
    - from: "scripts/common.sh"
      to: "scripts/lib/json.sh"
      via: "source at position 6 (after cleanup.sh, before output.sh)"
      pattern: "source.*json.sh"
---

<objective>
Build the complete JSON output infrastructure for the networking-tools project: create `lib/json.sh` with 5 public functions, wire it into the module load chain, add `-j`/`--json` flag parsing to `args.sh`, and integrate JSON mode branches into `output.sh`.

Purpose: This is the foundation for v1.4 JSON Output Mode. Once this plan is complete, any use-case script that uses `run_or_show` will automatically support `-j` for structured JSON output. Phase 25 (script migration) adds the per-script `json_set_meta` / `json_finalize` calls.

Output: 1 new file (`scripts/lib/json.sh`), 3 modified files (`common.sh`, `args.sh`, `output.sh`)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-json-library-flag-integration/23-RESEARCH.md

@scripts/common.sh
@scripts/lib/json.sh
@scripts/lib/args.sh
@scripts/lib/output.sh
@scripts/lib/colors.sh
@scripts/lib/cleanup.sh
@scripts/lib/strict.sh
@scripts/lib/logging.sh
@scripts/nmap/discover-live-hosts.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/json.sh and wire into common.sh</name>
  <files>scripts/lib/json.sh, scripts/common.sh</files>
  <action>
Create `scripts/lib/json.sh` with the following structure. Follow the exact same module pattern as all existing lib modules (source guard, header comment block).

**Header:**
```
#!/usr/bin/env bash
# ============================================================================
# @description  JSON output mode: state management, result accumulation, envelope finalization
# @usage        Sourced via common.sh (not invoked directly)
# @dependencies cleanup.sh (make_temp)
# ============================================================================
```

**Source guard:**
```bash
[[ -n "${_JSON_LOADED:-}" ]] && return 0
_JSON_LOADED=1
```

**State variables (module-level):**
```bash
JSON_MODE="${JSON_MODE:-0}"
_JSON_TOOL=""
_JSON_TARGET=""
_JSON_SCRIPT=""
_JSON_STARTED=""
_JSON_RESULTS=()
```

**Internal function `_json_check_jq`:** Sets `_JSON_JQ_AVAILABLE=1` if `command -v jq` succeeds, `0` otherwise. Call at load time. Never exits. Uses plain `echo >&2` (not library logging -- avoid circular dependency).

**Internal function `_json_require_jq`:** If `_JSON_JQ_AVAILABLE != 1`, print install hint (`echo "[ERROR] jq is required for JSON output (-j). Install: brew install jq (macOS) or apt install jq (Linux)" >&2`) and `exit 1`. Called from `args.sh` when `-j` is actually parsed.

**Public function `json_is_active`:** Returns 0 (true) if `JSON_MODE == 1`, else returns 1 (false). One-liner: `[[ "${JSON_MODE:-0}" == "1" ]]`

**Public function `json_set_meta`:** Takes 2 args: `tool` and `target`. Sets `_JSON_TOOL="$1"`, `_JSON_TARGET="${2:-}"`, `_JSON_SCRIPT="$(basename "${BASH_SOURCE[1]}" .sh)"`, `_JSON_STARTED="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"`. Guard with `json_is_active || return 0` so it's a no-op when JSON mode is off.

**Public function `json_add_result`:** Takes 5 args: `description`, `exit_code`, `stdout`, `stderr`, `command`. Builds a JSON object using `jq -n --arg desc "$description" --argjson code "$exit_code" --arg out "$stdout" --arg err "$stderr" --arg cmd "$command" '{description: $desc, command: $cmd, exit_code: $code, stdout: $out, stderr: $err}'`. Appends to `_JSON_RESULTS` array. Guard with `json_is_active || return 0`.

**Public function `json_add_example`:** Takes 2 args: `description`, `command`. Builds JSON object using `jq -n --arg desc "$description" --arg cmd "$command" '{description: $desc, command: $cmd}'`. Appends to `_JSON_RESULTS` array. Guard with `json_is_active || return 0`.

**Public function `json_finalize`:** Assembles the complete envelope and writes to fd3 (original stdout) if open, or stdout as fallback (for testing).
- Set `finished="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"`
- Set `count=${#_JSON_RESULTS[@]}`
- Build `results_json`: if count > 0, use `printf '%s\n' "${_JSON_RESULTS[@]}" | jq -s '.'`, else `"[]"`
- Set `mode="show"` then `[[ "${EXECUTE_MODE:-show}" == "execute" ]] && mode="execute"`
- Build envelope with `jq -n` using `--arg` for strings and `--argjson` for count, results. Schema:
  ```
  { meta: { tool, script, target, started, finished, mode },
    results: $results,
    summary: { total: $count,
               succeeded: (execute mode: count exit_code==0, show mode: $count),
               failed: (execute mode: count exit_code!=0, show mode: 0) } }
  ```
- Write to fd3 if open, else stdout: `if { true >&3; } 2>/dev/null; then jq ... >&3; else jq ...; fi`
- Guard with `json_is_active || return 0`.

**Call `_json_check_jq` at the end of the file** (after all function definitions) so it runs at source time.

**Modify `scripts/common.sh`:**
1. Add `source "${_LIB_DIR}/json.sh"` AFTER the `cleanup.sh` line and BEFORE the `output.sh` line (position 6 in load order).
2. Update the `@dependencies` header comment to include `lib/json.sh` in the list.

The final source order in common.sh should be:
```
strict.sh
colors.sh
logging.sh
validation.sh
cleanup.sh
json.sh        # NEW
output.sh
args.sh
diagnostic.sh
nc_detect.sh
```
  </action>
  <verify>
Run: `bash -c 'source scripts/common.sh && type json_is_active && type json_set_meta && type json_add_result && type json_add_example && type json_finalize && echo "All 5 functions defined"'`

Verify source guard: `bash -c 'source scripts/lib/json.sh; source scripts/lib/json.sh; echo "Double source OK"'`

Verify jq check runs at load time: `bash -c 'source scripts/common.sh && echo "_JSON_JQ_AVAILABLE=${_JSON_JQ_AVAILABLE}"'` should show 1 (assuming jq is installed).

Run existing test suite to confirm no regressions: `bats tests/`
  </verify>
  <done>
`scripts/lib/json.sh` exists with source guard, 5 public functions (json_is_active, json_set_meta, json_add_result, json_add_example, json_finalize), 2 internal functions (_json_check_jq, _json_require_jq). `scripts/common.sh` sources json.sh at position 6. All existing tests pass. Sourcing common.sh defines all 5 JSON functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add -j flag parsing to args.sh and JSON branches to output.sh</name>
  <files>scripts/lib/args.sh, scripts/lib/output.sh</files>
  <action>
**Modify `scripts/lib/args.sh`:**

1. Add `JSON_MODE="${JSON_MODE:-0}"` initialization near the top, after `EXECUTE_MODE` init (line 13).

2. Add `-j|--json` case to the `parse_common_args` while loop, between the `-x|--execute` case and the `--` case:
```bash
-j|--json)
    JSON_MODE=1
    ;;
```

3. Add a JSON activation block AFTER the while loop ends (after the `done` on current line 57), BEFORE the closing `}` of parse_common_args. This block runs when `-j` was parsed:
```bash
if [[ "${JSON_MODE:-0}" == "1" ]]; then
    _json_require_jq
    export NO_COLOR=1
    # Reset color vars -- colors.sh already evaluated at source time (Pitfall 4)
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' NC=''
    exec 3>&1       # Save original stdout as fd3
    exec 1>&2       # Redirect all stdout to stderr
fi
```

4. Update the comment on line 22 to include `-j/--json` in the handled flags list: `# Handles: -h/--help, -v/--verbose, -q/--quiet, -x/--execute, -j/--json, --`

IMPORTANT: Do NOT auto-enable `-x` when `-j` is passed. `-j` and `-x` are independent flags per FLAG-02/FLAG-03.

**Modify `scripts/lib/output.sh`:**

1. Add `json_is_active && return 0` as the FIRST line inside `safety_banner()` (before the echo lines). This suppresses the authorization banner in JSON mode (Pitfall 6 from research). Add a comment: `# Suppress in JSON mode -- banner is informational, not a control`.

2. Add `json_is_active && return 0` as the SECOND guard in `confirm_execute()`, right after the existing `[[ "${EXECUTE_MODE:-show}" != "execute" ]] && return 0` line and BEFORE the `[[ ! -t 0 ]]` check. Add a comment: `# Skip interactive prompt in JSON mode (FLAG-04)`.

3. Replace the `run_or_show()` function body with 4 code paths. Keep the same function signature (`local description="$1"; shift`):

```bash
run_or_show() {
    local description="$1"
    shift

    if [[ "${EXECUTE_MODE:-show}" == "execute" ]]; then
        if json_is_active; then
            # Execute+JSON: capture output, accumulate result
            local stdout_file stderr_file cmd_exit_code
            stdout_file=$(make_temp)
            stderr_file=$(make_temp)
            "$@" > "$stdout_file" 2> "$stderr_file" && cmd_exit_code=0 || cmd_exit_code=$?
            json_add_result "$description" "$cmd_exit_code" "$(<"$stdout_file")" "$(<"$stderr_file")" "$*"
        else
            # Execute+text: existing behavior
            info "$description"
            debug "Executing: $*"
            "$@"
            echo ""
        fi
    else
        if json_is_active; then
            # Show+JSON: accumulate example command
            json_add_example "$description" "$*"
        else
            # Show+text: existing behavior
            info "$description"
            echo "   $*"
            echo ""
        fi
    fi
}
```

The `@dependencies` header comment in output.sh should be updated to include: `colors.sh, json.sh, cleanup.sh`
  </action>
  <verify>
**Flag parsing:**
Run: `bash -c 'source scripts/common.sh; parse_common_args -j; echo "JSON_MODE=$JSON_MODE"'` -- should output `JSON_MODE=1` (on stderr due to fd redirect).

Run: `bash -c 'source scripts/common.sh; parse_common_args -j -x; echo "JSON_MODE=$JSON_MODE EXECUTE_MODE=$EXECUTE_MODE"'` -- should show both active.

Run: `bash -c 'source scripts/common.sh; parse_common_args --json; echo "JSON_MODE=$JSON_MODE"'` -- long form works.

**No-jq safety:**
Run: `bash scripts/nmap/discover-live-hosts.sh localhost` -- should work exactly as before (no -j, no jq needed).

**Show+JSON mode (the key integration test):**
Run: `bash scripts/nmap/discover-live-hosts.sh -j localhost 3>&1 1>/dev/null 2>/dev/null` -- should produce nothing yet (json_set_meta/json_finalize not called in the script -- that's Phase 25). But should NOT error.

**JSON mode with manual finalize (proves the plumbing works):**
Run:
```bash
bash -c '
source scripts/common.sh
show_help() { echo "help"; }
parse_common_args -j
json_set_meta "test" "localhost"
json_add_example "1) Test command" "echo hello"
json_finalize
' 3>&1 1>/dev/null 2>/dev/null
```
Should produce valid JSON on fd3 with meta, results (1 example), summary.

**Regression:** Run `bats tests/` -- all existing tests pass.

**safety_banner skip:** `bash -c 'source scripts/common.sh; JSON_MODE=1; safety_banner; echo "should not print banner"'` -- safety_banner should return immediately.

**confirm_execute skip:** `bash -c 'source scripts/common.sh; JSON_MODE=1; EXECUTE_MODE=execute; confirm_execute "target"; echo "did not block"'` -- should not prompt.
  </verify>
  <done>
`args.sh` recognizes `-j`/`--json`, sets `JSON_MODE=1`, calls `_json_require_jq`, sets `NO_COLOR=1`, resets color vars, sets up fd3 redirect. `output.sh` has 4-path `run_or_show` (show+text, execute+text, show+JSON, execute+JSON), `safety_banner` skips in JSON mode, `confirm_execute` skips in JSON mode. All existing tests pass. A manual integration test producing JSON via `json_set_meta` + `json_add_example` + `json_finalize` outputs valid JSON parseable by `jq`.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full infrastructure end-to-end:

1. **Existing behavior preserved:** `bash scripts/nmap/discover-live-hosts.sh localhost` produces normal text output (no regression).

2. **JSON plumbing works:** The following command produces valid JSON with the correct envelope structure:
```bash
bash -c '
source scripts/common.sh
show_help() { echo "help"; }
parse_common_args -j
json_set_meta "nmap" "localhost"
run_or_show "1) Test ping sweep" nmap -sn localhost
run_or_show "2) Test list scan" nmap -sL localhost
json_finalize
' 3>&1 1>/dev/null 2>/dev/null | jq .
```
This should show `meta.tool = "nmap"`, `results` array with 2 examples (descriptions + commands), `summary.total = 2`.

3. **Execute+JSON plumbing works:**
```bash
bash -c '
source scripts/common.sh
show_help() { echo "help"; }
parse_common_args -j -x
json_set_meta "test" "localhost"
run_or_show "1) Echo test" echo "hello world"
json_finalize
' 3>&1 1>/dev/null 2>/dev/null | jq .
```
This should show `meta.mode = "execute"`, `results[0].exit_code = 0`, `results[0].stdout = "hello world\n"`.

4. **RFC 8259 escaping:** Test with special characters:
```bash
bash -c '
source scripts/common.sh
show_help() { echo "help"; }
parse_common_args -j -x
json_set_meta "test" "localhost"
run_or_show "Special chars test" echo -e "line1\nline2\ttab\"quote"
json_finalize
' 3>&1 1>/dev/null 2>/dev/null | jq .
```
Must produce valid JSON (jq exits 0).

5. **Existing tests pass:** `bats tests/` -- all green.
</verification>

<success_criteria>
- `scripts/lib/json.sh` exists with 5 public functions and 2 internal functions
- `scripts/common.sh` loads json.sh at position 6 (after cleanup.sh, before output.sh)
- `scripts/lib/args.sh` parses `-j`/`--json`, activates JSON mode with fd3 redirect
- `scripts/lib/output.sh` has 4-path run_or_show, safety_banner skip, confirm_execute skip
- All 265 existing BATS tests pass (zero regressions)
- Manual integration test produces valid JSON envelope parseable by `jq .`
- JSON mode does not activate when `-j` is not passed (lazy jq dependency)
</success_criteria>

<output>
After completion, create `.planning/phases/23-json-library-flag-integration/23-01-SUMMARY.md`
</output>
