---
phase: 16-use-case-script-migration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/dig/query-dns-records.sh
  - scripts/dig/attempt-zone-transfer.sh
  - scripts/dig/check-dns-propagation.sh
  - scripts/curl/check-ssl-certificate.sh
  - scripts/curl/debug-http-response.sh
  - scripts/curl/test-http-endpoints.sh
autonomous: true

must_haves:
  truths:
    - "Running any of the 6 migrated scripts with --help prints usage and exits 0"
    - "Running any of the 6 migrated scripts without -x produces identical educational output to pre-migration"
    - "Running any of the 6 migrated scripts with -x and piped stdin rejects with interactive terminal warning"
  artifacts:
    - path: "scripts/dig/query-dns-records.sh"
      provides: "DNS record querying dual-mode"
      contains: "parse_common_args"
    - path: "scripts/dig/attempt-zone-transfer.sh"
      provides: "DNS zone transfer dual-mode"
      contains: "parse_common_args"
    - path: "scripts/dig/check-dns-propagation.sh"
      provides: "DNS propagation checking dual-mode"
      contains: "parse_common_args"
    - path: "scripts/curl/check-ssl-certificate.sh"
      provides: "SSL certificate checking dual-mode"
      contains: "parse_common_args"
    - path: "scripts/curl/debug-http-response.sh"
      provides: "HTTP response debugging dual-mode"
      contains: "parse_common_args"
    - path: "scripts/curl/test-http-endpoints.sh"
      provides: "HTTP endpoint testing dual-mode"
      contains: "parse_common_args"
  key_links:
    - from: "each migrated script"
      to: "scripts/lib/args.sh"
      via: "parse_common_args call"
      pattern: "parse_common_args"
    - from: "each migrated script"
      to: "scripts/lib/output.sh"
      via: "run_or_show and confirm_execute calls"
      pattern: "run_or_show|confirm_execute"
---

<objective>
Migrate 6 dig and curl use-case scripts to the dual-mode pattern: query-dns-records, attempt-zone-transfer, check-dns-propagation, check-ssl-certificate, debug-http-response, test-http-endpoints.

Purpose: Target-required scripts with clean single-command examples. Most examples convert to run_or_show. curl scripts have format string edge cases requiring info+echo.
Output: 6 scripts accepting -h/-v/-q/-x flags with run_or_show for eligible examples.
</objective>

<execution_context>
@/Users/patrykattc/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrykattc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-use-case-script-migration/16-RESEARCH.md
@.planning/phases/15-examples-script-migration/15-01-SUMMARY.md
@.planning/phases/15-examples-script-migration/15-02-SUMMARY.md
@scripts/nmap/examples.sh (reference pattern -- already migrated)
@scripts/lib/args.sh
@scripts/lib/output.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate dig/query-dns-records, dig/attempt-zone-transfer, dig/check-dns-propagation</name>
  <files>
    scripts/dig/query-dns-records.sh
    scripts/dig/attempt-zone-transfer.sh
    scripts/dig/check-dns-propagation.sh
  </files>
  <action>
Apply the proven migration pattern to each script. For each:

1. Replace `[[ "${1:-}" =~ ^(-h|--help)$ ]] && show_help && exit 0` with `parse_common_args "$@"` + `set -- "${REMAINING_ARGS[@]+${REMAINING_ARGS[@]}}"`.
2. Add `confirm_execute "${1:-}"` between TARGET assignment and `safety_banner`.
3. Convert eligible examples to `run_or_show`.
4. Guard interactive demo with `EXECUTE_MODE`.

**Per-script notes:**

- **query-dns-records.sh**: All 10 examples are single `dig` commands using `${TARGET}`. Convert all 10 to run_or_show. Example 7 uses `www.${TARGET}` -- use `"www.$TARGET"` in run_or_show arg. Example 10 uses `@1.1.1.1` -- that's fine for run_or_show: `dig @1.1.1.1 "$TARGET" A +noall +answer`.

- **attempt-zone-transfer.sh**: This script has a mix. Examples 1, 5, 8 are single `dig` commands with `${TARGET}` -- convert to run_or_show. Examples 2, 3, 4, 6, 7 use subshell expansion `@$(dig ${TARGET} NS +short | head -1)` -- these are complex pipeline commands, keep as info+echo. Example 9 is a for loop -- keep as info+echo. Example 10 writes to a file (`> zone-${TARGET}.txt`) -- keep as info+echo. Total: 3 convertible.

- **check-dns-propagation.sh**: All 10 examples are for loops iterating over resolvers -- keep ALL as info+echo (for loops are not single executable commands for run_or_show). Note the `RESOLVERS` array variable -- preserve it unchanged. Total: 0 convertible. This is a structural-only migration (parse_common_args + confirm_execute + EXECUTE_MODE guard).
  </action>
  <verify>
For each of the 3 scripts, run:
1. `bash scripts/dig/query-dns-records.sh --help` -- exits 0, shows "Usage:"
2. `bash scripts/dig/attempt-zone-transfer.sh -h` -- exits 0
3. `echo "" | bash scripts/dig/check-dns-propagation.sh -x example.com 2>&1` -- exits non-zero, mentions "interactive terminal"
4. Verify each script contains `parse_common_args`, `confirm_execute`, and `EXECUTE_MODE`
  </verify>
  <done>
Three dig use-case scripts accept dual-mode flags. query-dns-records has 10 run_or_show examples. attempt-zone-transfer has 3 run_or_show (complex subshell pipelines preserved as info+echo). check-dns-propagation has 0 conversions (all for loops).
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate curl/check-ssl-certificate, curl/debug-http-response, curl/test-http-endpoints</name>
  <files>
    scripts/curl/check-ssl-certificate.sh
    scripts/curl/debug-http-response.sh
    scripts/curl/test-http-endpoints.sh
  </files>
  <action>
Apply the same migration pattern. curl scripts have format string edge cases per Phase 15-02 decisions.

**Per-script notes:**

- **check-ssl-certificate.sh**: Has special TARGET stripping: `TARGET="${TARGET#https://}"` and `TARGET="${TARGET#http://}"` -- preserve these AFTER `set --`. Examples 1-8, 10 use `${TARGET}` in single `curl` commands -- but many use complex `-w` format strings and `2>&1 | grep` pipes. Apply this rule: examples with `| grep` pipe are still single pipelines that work in run_or_show. However, examples using `%{http_code}` format strings with embedded `\n` need careful quoting. Convert examples 1, 2, 5, 8, 10 to run_or_show (simple curl + grep patterns). Keep examples 3, 4, 7 as info+echo (complex `-w` format strings with `%{http_code}\n` would need awkward quoting in run_or_show). Keep example 6 as info+echo (uses `$(dig ...)` subshell). Keep example 9 as info+echo (two separate commands on two echo lines).

- **debug-http-response.sh**: Has a `TIMING_FMT` variable defined before the examples. ALL 10 examples use complex `-w` format strings with `%{time_namelookup}`, `%{http_code}`, etc. Per Phase 15-02 decision: "Complex format strings (curl timing) kept as info+echo for output fidelity." Keep ALL 10 as info+echo. This is a structural-only migration. Preserve the `TIMING_FMT` variable.

- **test-http-endpoints.sh**: Examples 1-9 use `${TARGET}` in single `curl` commands. Many use `-w '%{http_code}\n'` format strings. Convert examples 4 (PUT -- single curl), 7 (HEAD -- simple `-I -s`), 8 (OPTIONS -- `-X OPTIONS -i -s`) to run_or_show. Keep examples 1, 2, 5, 9 as info+echo (complex `-w '%{http_code}\n'` format strings). Keep examples 3, 6 as info+echo (JSON body with embedded quotes). Keep example 10 as info+echo (`| grep` with `-E` regex and multi-pipe). Total: 3 convertible.

Actually -- reconsider. The `-w` format strings like `curl -s -o /dev/null -w 'HTTP %{http_code}\n' ${TARGET}` CAN work as run_or_show arguments if properly quoted. The issue is the `\n` being interpreted. In run_or_show, the command is exec'd, so format strings pass through correctly. But the display in show mode needs to match the original echo format. Given the Phase 15 precedent of keeping format strings as info+echo for consistency, KEEP the same pattern here.

Final conversion counts:
- check-ssl-certificate.sh: Convert examples 1, 2, 5, 8, 10 (simple grep pipes). Keep 3, 4, 6, 7, 9 as info+echo.
- debug-http-response.sh: 0 conversions (all format strings).
- test-http-endpoints.sh: Convert example 7 (`curl -I -s $TARGET`) and example 8 (`curl -X OPTIONS -i -s $TARGET`). Keep rest as info+echo (format strings, JSON bodies, multi-command). Total: 2 convertible.
  </action>
  <verify>
For each of the 3 scripts, run:
1. `bash scripts/curl/check-ssl-certificate.sh --help` -- exits 0, shows "Usage:"
2. `bash scripts/curl/debug-http-response.sh -h` -- exits 0
3. `echo "" | bash scripts/curl/test-http-endpoints.sh -x https://example.com 2>&1` -- exits non-zero, mentions "interactive terminal"
4. Verify each script contains `parse_common_args`, `confirm_execute`, and `EXECUTE_MODE`
5. Verify `debug-http-response.sh` preserves the `TIMING_FMT` variable
  </verify>
  <done>
Three curl use-case scripts accept dual-mode flags. check-ssl-certificate has 5 run_or_show. debug-http-response has 0 conversions (all format strings per Phase 15-02 precedent). test-http-endpoints has 2 run_or_show. Complex format strings and JSON bodies preserved as info+echo.
  </done>
</task>

</tasks>

<verification>
For all 6 scripts:
1. `--help` and `-h` both exit 0 and print "Usage:"
2. Running with a target (no -x) produces educational output containing numbered examples
3. `-x` with piped stdin exits non-zero with "interactive terminal" warning
4. grep confirms `parse_common_args`, `confirm_execute`, `EXECUTE_MODE` present in each file
5. curl/check-ssl-certificate.sh preserves TARGET stripping logic
6. curl/debug-http-response.sh preserves TIMING_FMT variable
</verification>

<success_criteria>
All 6 dig and curl use-case scripts accept dual-mode flags and produce backward-compatible output.
</success_criteria>

<output>
After completion, create `.planning/phases/16-use-case-script-migration/16-02-SUMMARY.md`
</output>
